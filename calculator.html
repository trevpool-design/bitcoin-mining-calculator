<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Pantheon Mining Calculator v8.3</title>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    :root{
      --bg:#0B1C2D;
      --panel:#121E2B;
      --panel2:#162638;
      --text:#F5F7FA;
      --muted:#8A95A3;
      --line:#263647;
      --accent:#F7931A;
      --accent2:#D9822B;
      --warn:#E5B454;
      --danger:#D66A6A;
      --success:#34D399;
      --radius:14px;
      --transition-fast:0.15s ease;
      --transition-med:0.25s ease;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:linear-gradient(180deg,#081521,#0B1C2D 35%, #081521);
      color:var(--text);
    }
    .container{
      max-width:1280px;
      margin:22px auto;
      padding:0 14px;
      display:grid;
      grid-template-columns: 380px 1fr;
      gap:16px;
    }
    .sidebar,.main{
      background:rgba(17,24,39,.86);
      border:1px solid rgba(35,48,71,.8);
      border-radius:var(--radius);
      box-shadow:0 10px 30px rgba(0,0,0,.35);
      overflow:hidden;
    }
    .sidebar{
      padding:16px 16px 18px;
      position:sticky;
      top:14px;
      height:calc(100dvh - 28px);
      overflow:auto;
    }
    .main{padding:14px}
    h2,h3{margin:0 0 10px}
    h2{font-size:18px}
    h3{font-size:14px; color:#f3f4f6}
    label{display:block; margin-top:12px; color:var(--muted); font-size:12px}
    select,input[type="number"],input[type="text"]{
      width:100%;
      margin-top:6px;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(35,48,71,.9);
      background:rgba(15,23,42,.7);
      color:var(--text);
      outline:none;
    }
    input[readonly]{opacity:.9}
    .row{display:flex; gap:10px; align-items:center}
    .row > *{flex:1}
    .counter{
      display:grid;
      grid-template-columns:44px 1fr 44px;
      gap:8px;
      align-items:center;
      margin-top:6px;
    }
    .btn{
      border:1px solid rgba(35,48,71,.9);
      background:rgba(15,23,42,.7);
      color:var(--text);
      border-radius:12px;
      padding:10px;
      cursor:pointer;
      transition:.15s transform, .15s background;
      user-select:none;
    }
    .btn:hover{background:rgba(15,23,42,.92); transform:translateY(-1px)}
    .btn:active{transform:scale(.98) translateY(0)}
    .btn.small{padding:8px 10px; border-radius:11px; font-size:12px}
    .btn.primary{border-color:rgba(96,165,250,.75); background:rgba(96,165,250,.15)}
    .btn.ghost{background:transparent}
    .btn.danger{border-color:rgba(251,113,133,.65); background:rgba(251,113,133,.12)}
    .capex{margin:8px 0 0; color:var(--muted); font-size:12px}
    .scenarios{display:flex; gap:8px; margin-top:6px}
    .scenario-btn{flex:1}
    .scenario-btn.active{border-color:rgba(52,211,153,.75); background:rgba(52,211,153,.14)}
    .price-row{display:grid; grid-template-columns:1fr 44px; gap:8px; align-items:center; margin-top:6px}
    .refresh-btn{width:44px}
    .tabs{display:flex; gap:8px; margin-bottom:12px}
    .tab-btn{flex:1}
    .tab-btn.active{border-color:rgba(96,165,250,.75); background:rgba(96,165,250,.15)}
    .tab-content{display:none}
    .tab-content.active{display:block}
    .tiles{
      display:grid;
      grid-template-columns:repeat(3, minmax(0,1fr));
      gap:10px;
      margin:10px 0 14px;
    }
    .tile{
      background:rgba(15,23,42,.55);
      border:1px solid rgba(35,48,71,.8);
      border-radius:var(--radius);
      padding:12px;
      min-height:70px;
      transition:transform var(--transition-fast), border-color var(--transition-fast), box-shadow var(--transition-fast);
    }
    .tile:hover{
      transform:translateY(-2px);
      border-color:rgba(247,147,26,.3);
      box-shadow:0 4px 16px rgba(0,0,0,.2)
    }
    .tile h4,.tile h3{
      margin:0 0 6px;
      font-size:12px;
      color:var(--muted);
      font-weight:600;
      letter-spacing:.2px;
    }
    .tile p{margin:0; font-size:18px; font-weight:700}
    .graph-title{margin-top:10px}
    /* Chart.js canvas sizing: keep charts from growing with content */
.chart-box{height:260px;}
.chart-box canvas{width:100% !important; height:100% !important;}
canvas{background:rgba(15,23,42,.35); border:1px solid rgba(35,48,71,.7); border-radius:var(--radius);}
    table{
      width:100%;
      border-collapse:collapse;
      overflow:hidden;
      border-radius:var(--radius);
      border:1px solid rgba(35,48,71,.8);
      background:rgba(15,23,42,.35);
    }
    th,td{
      padding:10px 8px;
      border-bottom:1px solid rgba(35,48,71,.6);
      font-size:12px;
      text-align:right;
      white-space:nowrap;
    }
    th:first-child, td:first-child{text-align:left}
    th{color:var(--muted); font-weight:600; background:rgba(17,24,39,.6)}
    tr:hover td{background:rgba(96,165,250,.05)}
    .yearly-tiles{display:grid; grid-template-columns:repeat(5,minmax(0,1fr)); gap:10px}
    .yearly-tiles .tile p{font-size:14px}
    .comparison{display:grid; grid-template-columns:1fr 1fr; gap:10px}
    .muted{color:var(--muted)}
    .divider{height:1px; background:rgba(35,48,71,.8); margin:12px 0}
    .slider-wrap{
      margin-top:6px;
      display:grid;
      grid-template-columns:1fr 86px;
      gap:10px;
      align-items:center;
    }
    input[type="range"]{
      width:100%;
      height:6px;
      -webkit-appearance:none;
      appearance:none;
      background:rgba(35,48,71,.6);
      border-radius:3px;
      outline:none;
      cursor:pointer;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width:18px;
      height:18px;
      background:linear-gradient(135deg, #D4A85A, #C9973B);
      border-radius:50%;
      border:2px solid rgba(255,255,255,.2);
      box-shadow:0 2px 6px rgba(0,0,0,.3);
      cursor:pointer;
      transition:transform 0.15s ease, box-shadow 0.15s ease;
    }
    input[type="range"]::-webkit-slider-thumb:hover{
      transform:scale(1.1);
      box-shadow:0 3px 10px rgba(212,168,90,.4);
    }
    input[type="range"]::-moz-range-thumb{
      width:18px;
      height:18px;
      background:linear-gradient(135deg, #D4A85A, #C9973B);
      border-radius:50%;
      border:2px solid rgba(255,255,255,.2);
      box-shadow:0 2px 6px rgba(0,0,0,.3);
      cursor:pointer;
    }
    input[type="range"]::-moz-range-track{
      height:6px;
      background:rgba(35,48,71,.6);
      border-radius:3px;
    }
    input[type="range"]:focus::-webkit-slider-thumb{
      box-shadow:0 0 0 3px rgba(212,168,90,.3);
    }

    /* Halving Anchor Date - Professional styling */
    input[type="date"]{
      width:100%;
      margin-top:6px;
      padding:12px 14px;
      border-radius:12px;
      border:1px solid rgba(212,168,90,.3);
      background:linear-gradient(135deg, rgba(212,168,90,.08), rgba(15,23,42,.7));
      color:var(--text);
      font-size:13px;
      font-weight:500;
      outline:none;
      cursor:pointer;
      transition:border-color var(--transition-fast), box-shadow var(--transition-fast);
    }
    input[type="date"]:hover{
      border-color:rgba(212,168,90,.5);
    }
    input[type="date"]:focus{
      border-color:rgba(212,168,90,.6);
      box-shadow:0 0 0 3px rgba(212,168,90,.15);
    }
    input[type="date"]::-webkit-calendar-picker-indicator{
      filter:invert(0.7) sepia(0.5) saturate(2) hue-rotate(10deg);
      cursor:pointer;
      opacity:0.7;
      transition:opacity 0.15s ease;
    }
    input[type="date"]::-webkit-calendar-picker-indicator:hover{
      opacity:1;
    }
    .pill{
      display:inline-flex; gap:6px; align-items:center;
      padding:6px 10px; border-radius:999px;
      background:rgba(15,23,42,.55);
      border:1px solid rgba(35,48,71,.8);
      color:var(--muted);
      font-size:12px;
    }
    .note{
      margin-top:8px;
      font-size:12px;
      color:var(--muted);
      line-height:1.35;
    }
    .sticky-actions{
      position:sticky; bottom:0;
      padding:12px 0 0;
      background:linear-gradient(180deg, rgba(17,24,39,0), rgba(17,24,39,.94) 35%, rgba(17,24,39,1));
    }
    @media (max-width: 980px){
      .container{grid-template-columns:1fr}
      .sidebar{position:relative; height:auto; max-height:none}
      .tiles{grid-template-columns:1fr 1fr}
      .yearly-tiles{grid-template-columns:repeat(2,minmax(0,1fr))}
      .comparison{grid-template-columns:1fr}
      .tabs{flex-wrap:wrap}
      .tab-btn{flex:1 1 45%; font-size:12px; padding:8px 6px}
      .sticky-actions{position:relative; background:transparent}
      .sticky-actions .row{flex-wrap:wrap}
      .sticky-actions .btn{flex:1 1 45%; margin-bottom:6px}
    }
    @media (max-width: 600px){
      body{font-size:14px}
      .container{margin:10px auto; padding:0 8px; gap:10px}
      .sidebar,.main{padding:12px; border-radius:12px}
      .tiles{grid-template-columns:1fr}
      .tile{padding:10px; min-height:60px}
      .tile p{font-size:16px}
      .yearly-tiles{grid-template-columns:1fr}
      h2{font-size:16px}
      h3{font-size:13px}
      label{font-size:11px}
      .btn{padding:8px; font-size:12px}
      .tabs{gap:4px}
      .tab-btn{flex:1 1 100%; padding:10px}
      .chart-box{height:200px}
      .table-scroll{font-size:11px}
      .table-scroll table{min-width:900px}
      .slider-wrap{grid-template-columns:1fr 70px}
      .counter{grid-template-columns:38px 1fr 38px}
      .perf-indicator{display:none}
    }
    @media (max-width: 400px){
      .tile p{font-size:14px}
      .sidebar{padding:10px}
      .main{padding:10px}
    }

    /* Print styles for professional reports */
    @media print{
      body{background:#fff; color:#000}
      .sidebar{display:none}
      .container{display:block; max-width:100%}
      .main{box-shadow:none; border:none; background:#fff}
      .tabs{display:none}
      .tab-content{display:block !important; page-break-inside:avoid}
      .tile{border:1px solid #ccc; background:#f9f9f9}
      .chart-box{height:300px}
      .perf-indicator{display:none}
    }
  
    /* Cashflow table usability */
    .table-scroll{
      width:100%;
      overflow:auto;
      border-radius:var(--radius);
      border:1px solid rgba(35,48,71,.8);
      background:rgba(15,23,42,.20);
    }
    .table-scroll table{
      border:0;
      min-width: 1100px; /* ensures horizontal scroll on narrow viewports */
      background:transparent;
    }
    .table-scroll thead th{
      position:sticky;
      top:0;
      z-index:3;
      background:rgba(17,24,39,.95);
      backdrop-filter: blur(6px);
    }
    .table-scroll tbody td{
      background:rgba(15,23,42,.20);
    }
    .table-scroll th:first-child,
    .table-scroll td:first-child{
      position:sticky;
      left:0;
      z-index:2;
      background:rgba(17,24,39,.92);
    }
    .table-scroll thead th:first-child{
      z-index:4;
    }

    /* Sticky table headers and first column */
    .table-scroll{position:relative}
    #cashflowTable thead th{position:sticky; top:0; z-index:3; background:rgba(11,18,32,.98); backdrop-filter:blur(8px)}
    #cashflowTable th:first-child, #cashflowTable td:first-child{position:sticky; left:0; z-index:2; background:rgba(11,18,32,.98)}
    #cashflowTable thead th:first-child{z-index:4}
    tr.year-subtotal td{background:rgba(148,163,184,.08); font-weight:700}

    /* Loading states */
    .loading{position:relative;pointer-events:none}
    .loading::after{
      content:'';position:absolute;top:50%;left:50%;
      width:18px;height:18px;margin:-9px 0 0 -9px;
      border:2px solid rgba(247,147,26,.3);border-top-color:var(--accent);
      border-radius:50%;animation:spin .6s linear infinite
    }
    @keyframes spin{to{transform:rotate(360deg)}}
    .btn.loading{color:transparent}
    .btn.loading::after{width:14px;height:14px;margin:-7px 0 0 -7px}

    /* Input validation states */
    input.warning{border-color:var(--warn) !important;background:rgba(229,180,84,.08) !important}
    input.error{border-color:var(--danger) !important;background:rgba(214,106,106,.08) !important}
    .validation-msg{font-size:11px;margin-top:4px;line-height:1.3}
    .validation-msg.warning{color:var(--warn)}
    .validation-msg.error{color:var(--danger)}
    .validation-msg.success{color:var(--success)}

    /* Smooth transitions */
    .tile,.tab-content,.chart-box{transition:opacity var(--transition-med)}
    .tile p{transition:color var(--transition-fast)}
    .fade-in{animation:fadeIn var(--transition-med) ease-out}
    @keyframes fadeIn{from{opacity:0;transform:translateY(4px)}to{opacity:1;transform:translateY(0)}}

    /* Performance indicator */
    .perf-indicator{
      position:fixed;bottom:12px;left:12px;
      font-size:10px;color:var(--muted);opacity:.5;
      font-family:ui-monospace,monospace;z-index:100
    }

    /* Monte Carlo progress */
    .mc-progress{
      height:3px;background:rgba(35,48,71,.8);border-radius:2px;
      margin-top:8px;overflow:hidden
    }
    .mc-progress-bar{
      height:100%;background:var(--accent);
      transition:width 0.1s linear;width:0%
    }

    /* Tooltip enhancements */
    [data-tooltip]{position:relative;cursor:help}
    [data-tooltip]:hover::before{
      content:attr(data-tooltip);
      position:absolute;bottom:calc(100% + 6px);left:50%;
      transform:translateX(-50%);
      padding:6px 10px;border-radius:8px;
      background:rgba(11,28,45,.95);border:1px solid var(--line);
      font-size:11px;color:var(--text);white-space:nowrap;
      z-index:1000;box-shadow:0 4px 12px rgba(0,0,0,.3)
    }

    /* Focus states for accessibility */
    input:focus,select:focus,button:focus{
      outline:2px solid rgba(247,147,26,.4);
      outline-offset:2px
    }

    /* Number formatting helper - tabular nums */
    .tile p,.yearly-tiles .tile p,td{font-variant-numeric:tabular-nums}

    /* Custom Price Projection Section */
    .price-projection-panel{
      margin-top:12px;
      padding:12px;
      background:rgba(15,23,42,.4);
      border:1px solid rgba(35,48,71,.8);
      border-radius:var(--radius);
    }
    .price-projection-panel.collapsed .price-projection-content{display:none}
    .price-projection-header{
      display:flex;align-items:center;justify-content:space-between;
      cursor:pointer;user-select:none
    }
    .price-projection-header h4{
      margin:0;font-size:13px;font-weight:600;color:var(--text)
    }
    .price-projection-toggle{
      font-size:11px;color:var(--muted);transition:transform var(--transition-fast)
    }
    .price-projection-panel:not(.collapsed) .price-projection-toggle{transform:rotate(180deg)}

    .price-model-selector{
      display:flex;gap:6px;margin:10px 0
    }
    .price-model-btn{
      flex:1;padding:8px 6px;font-size:11px;text-align:center;
      border:1px solid rgba(35,48,71,.9);background:rgba(15,23,42,.5);
      border-radius:10px;color:var(--muted);cursor:pointer;
      transition:all var(--transition-fast)
    }
    .price-model-btn:hover{background:rgba(15,23,42,.8)}
    .price-model-btn.active{
      border-color:rgba(247,147,26,.6);
      background:rgba(247,147,26,.12);
      color:var(--text)
    }

    .price-presets{
      display:flex;gap:4px;margin-bottom:10px
    }
    .price-preset-btn{
      flex:1;padding:6px 4px;font-size:10px;text-align:center;
      border:1px solid rgba(35,48,71,.8);background:transparent;
      border-radius:8px;color:var(--muted);cursor:pointer;
      transition:all var(--transition-fast)
    }
    .price-preset-btn:hover{background:rgba(35,48,71,.5);color:var(--text)}
    .price-preset-btn.active{
      border-color:rgba(52,211,153,.6);
      background:rgba(52,211,153,.1);
      color:var(--success)
    }

    .year-row{
      display:grid;
      grid-template-columns:50px 1fr 90px;
      gap:8px;
      align-items:center;
      margin-bottom:8px
    }
    .year-label{
      font-size:11px;font-weight:600;color:var(--muted)
    }
    .year-input{
      width:100%;padding:8px 10px;
      border:1px solid rgba(35,48,71,.9);
      background:rgba(15,23,42,.7);
      border-radius:10px;color:var(--text);
      font-size:13px;text-align:center
    }
    .year-input:focus{border-color:rgba(247,147,26,.5)}
    .year-price{
      font-size:12px;color:var(--text);
      font-weight:600;text-align:right;
      font-variant-numeric:tabular-nums
    }
    .year-price.negative{color:var(--danger)}
    .year-price.extreme{color:var(--warn)}

    /* Price Sparkline */
    .price-sparkline{
      height:60px;
      margin-top:10px;
      background:rgba(15,23,42,.3);
      border:1px solid rgba(35,48,71,.6);
      border-radius:10px;
      padding:6px;
      position:relative
    }
    .price-sparkline canvas{
      width:100%!important;height:100%!important;
      background:transparent!important;border:0!important
    }
    .sparkline-labels{
      display:flex;justify-content:space-between;
      font-size:9px;color:var(--muted);margin-top:4px
    }

    /* Cycle model controls - show/hide based on mode */
    .cycle-controls{transition:opacity var(--transition-med), max-height var(--transition-med)}
    .cycle-controls.hidden{opacity:0.4;pointer-events:none}

    /* ===== ENHANCED EXECUTIVE VIEW ===== */

    /* Hero metrics - big impact numbers */
    .exec-hero{
      display:grid;
      grid-template-columns:repeat(3,1fr);
      gap:12px;
      margin-bottom:16px
    }
    .hero-metric{
      background:linear-gradient(135deg, rgba(15,23,42,.8), rgba(22,38,56,.6));
      border:1px solid rgba(35,48,71,.9);
      border-radius:var(--radius);
      padding:20px 16px;
      text-align:center;
      position:relative;
      overflow:hidden
    }
    .hero-metric::before{
      content:'';position:absolute;top:0;left:0;right:0;height:3px;
      background:linear-gradient(90deg,transparent,var(--accent),transparent);
      opacity:0;transition:opacity var(--transition-med)
    }
    .hero-metric:hover::before{opacity:1}
    .hero-metric .label{
      font-size:11px;font-weight:600;
      color:var(--muted);text-transform:uppercase;
      letter-spacing:0.5px;margin-bottom:8px
    }
    .hero-metric .value{
      font-size:36px;font-weight:700;
      font-variant-numeric:tabular-nums;
      line-height:1;margin-bottom:6px;
      background:linear-gradient(135deg,var(--text),#a8b5c4);
      -webkit-background-clip:text;-webkit-text-fill-color:transparent;
      background-clip:text
    }
    .hero-metric .subtext{
      font-size:11px;color:var(--muted)
    }
    .hero-metric.positive .value{
      background:linear-gradient(135deg,#34D399,#10B981);
      -webkit-background-clip:text;-webkit-text-fill-color:transparent;
      background-clip:text
    }
    .hero-metric.negative .value{
      background:linear-gradient(135deg,#F87171,#EF4444);
      -webkit-background-clip:text;-webkit-text-fill-color:transparent;
      background-clip:text
    }
    .hero-metric.highlight{
      border-color:rgba(247,147,26,.4);
      background:linear-gradient(135deg, rgba(247,147,26,.08), rgba(22,38,56,.6))
    }
    .hero-metric.highlight .value{
      background:linear-gradient(135deg,#F7931A,#D9822B);
      -webkit-background-clip:text;-webkit-text-fill-color:transparent;
      background-clip:text
    }

    /* Investment scorecard */
    .exec-scorecard{
      background:rgba(15,23,42,.4);
      border:1px solid rgba(35,48,71,.8);
      border-radius:var(--radius);
      padding:16px;
      margin-bottom:16px
    }
    .scorecard-header{
      display:flex;align-items:center;justify-content:space-between;
      margin-bottom:14px
    }
    .scorecard-header h3{margin:0;font-size:14px;font-weight:600}
    .scorecard-grade{
      display:flex;align-items:center;gap:8px;
      padding:6px 14px;border-radius:20px;
      font-size:13px;font-weight:700
    }
    .scorecard-grade.excellent{background:rgba(52,211,153,.15);color:#34D399;border:1px solid rgba(52,211,153,.3)}
    .scorecard-grade.good{background:rgba(96,165,250,.15);color:#60A5FA;border:1px solid rgba(96,165,250,.3)}
    .scorecard-grade.fair{background:rgba(251,191,36,.15);color:#FCD34D;border:1px solid rgba(251,191,36,.3)}
    .scorecard-grade.poor{background:rgba(248,113,113,.15);color:#F87171;border:1px solid rgba(248,113,113,.3)}

    .scorecard-items{
      display:grid;
      grid-template-columns:repeat(2,1fr);
      gap:10px
    }
    .scorecard-item{
      display:flex;align-items:center;gap:10px;
      padding:10px 12px;
      background:rgba(15,23,42,.5);
      border-radius:10px;
      border:1px solid rgba(35,48,71,.6)
    }
    .scorecard-icon{
      width:32px;height:32px;border-radius:8px;
      display:flex;align-items:center;justify-content:center;
      font-size:14px;flex-shrink:0
    }
    .scorecard-icon.pass{background:rgba(52,211,153,.15);color:#34D399}
    .scorecard-icon.warn{background:rgba(251,191,36,.15);color:#FCD34D}
    .scorecard-icon.fail{background:rgba(248,113,113,.15);color:#F87171}
    .scorecard-text{flex:1;min-width:0}
    .scorecard-text .title{font-size:11px;color:var(--muted);margin-bottom:2px}
    .scorecard-text .result{font-size:13px;font-weight:600}

    /* Comparison block */
    .exec-comparison{
      display:grid;
      grid-template-columns:1fr auto 1fr;
      gap:12px;
      align-items:stretch;
      margin:16px 0
    }
    .compare-card{
      background:rgba(15,23,42,.5);
      border:1px solid rgba(35,48,71,.8);
      border-radius:var(--radius);
      padding:16px;
      text-align:center;
      position:relative
    }
    .compare-card.winner{
      border-color:rgba(52,211,153,.4);
      background:linear-gradient(135deg,rgba(52,211,153,.08),rgba(15,23,42,.5))
    }
    .compare-card.winner::after{
      content:'‚úì Better';position:absolute;top:-10px;left:50%;
      transform:translateX(-50%);
      padding:3px 10px;border-radius:10px;
      background:#34D399;color:#0B1C2D;
      font-size:10px;font-weight:700;text-transform:uppercase
    }
    .compare-card .method{
      font-size:11px;font-weight:600;color:var(--muted);
      text-transform:uppercase;letter-spacing:0.5px;margin-bottom:8px
    }
    .compare-card .btc-amount{
      font-size:24px;font-weight:700;margin-bottom:4px;
      font-variant-numeric:tabular-nums
    }
    .compare-card .btc-label{
      font-size:11px;color:var(--muted)
    }
    .compare-card .fiat-value{
      font-size:13px;color:var(--muted);margin-top:8px;
      font-variant-numeric:tabular-nums
    }
    .compare-vs{
      display:flex;align-items:center;justify-content:center;
      font-size:12px;font-weight:700;color:var(--muted);
      padding:0 8px
    }

    /* Advantage callout */
    .exec-advantage{
      background:linear-gradient(90deg,rgba(52,211,153,.1),transparent);
      border-left:3px solid #34D399;
      padding:12px 16px;
      margin:14px 0;
      border-radius:0 var(--radius) var(--radius) 0
    }
    .exec-advantage.negative{
      background:linear-gradient(90deg,rgba(248,113,113,.1),transparent);
      border-left-color:#F87171
    }
    .exec-advantage .adv-label{
      font-size:10px;font-weight:600;color:var(--muted);
      text-transform:uppercase;letter-spacing:0.5px;margin-bottom:4px
    }
    .exec-advantage .adv-value{
      font-size:18px;font-weight:700
    }
    .exec-advantage .adv-value.positive{color:#34D399}
    .exec-advantage .adv-value.negative{color:#F87171}
    .exec-advantage .adv-detail{
      font-size:11px;color:var(--muted);margin-top:4px
    }

    /* 5-year projection strip */
    .exec-timeline{
      display:flex;gap:6px;margin:14px 0
    }
    .timeline-year{
      flex:1;
      background:rgba(15,23,42,.5);
      border:1px solid rgba(35,48,71,.6);
      border-radius:10px;
      padding:10px 8px;
      text-align:center
    }
    .timeline-year .yr{font-size:10px;color:var(--muted);font-weight:600;margin-bottom:4px}
    .timeline-year .btc{font-size:13px;font-weight:700;margin-bottom:2px}
    .timeline-year .val{font-size:10px;color:var(--muted)}
    .timeline-year.current{border-color:rgba(247,147,26,.4);background:rgba(247,147,26,.08)}

    /* Key assumptions compact */
    .exec-assumptions{
      background:rgba(15,23,42,.3);
      border:1px solid rgba(35,48,71,.6);
      border-radius:var(--radius);
      padding:14px
    }
    .exec-assumptions h4{
      margin:0 0 10px;font-size:12px;font-weight:600;color:var(--muted)
    }
    .assumption-grid{
      display:grid;grid-template-columns:repeat(3,1fr);gap:8px
    }
    .assumption-item{
      font-size:11px;line-height:1.4
    }
    .assumption-item .label{color:var(--muted)}
    .assumption-item .value{font-weight:600;color:var(--text)}

    /* Mobile responsiveness for exec view */
    @media(max-width:980px){
      .exec-hero{grid-template-columns:1fr}
      .hero-metric{padding:16px}
      .hero-metric .value{font-size:28px}
      .scorecard-items{grid-template-columns:1fr}
      .exec-comparison{grid-template-columns:1fr;gap:8px}
      .compare-vs{padding:8px 0;transform:rotate(90deg)}
      .assumption-grid{grid-template-columns:repeat(2,1fr)}
    }
    @media(max-width:600px){
      .hero-metric .value{font-size:24px}
      .exec-timeline{flex-wrap:wrap}
      .timeline-year{flex:1 1 45%}
      .assumption-grid{grid-template-columns:1fr}
    }

</style>
</head>

<body>
  <div id="perfIndicator" class="perf-indicator"></div>

  <div id="errorBanner" style="display:none;position:fixed;left:12px;right:12px;bottom:12px;z-index:99999;background:rgba(15,23,42,.96);border:1px solid rgba(251,113,133,.65);border-radius:14px;padding:12px 14px;color:#e5e7eb;box-shadow:0 10px 30px rgba(0,0,0,.35)">
    <div style="display:flex;justify-content:space-between;gap:10px;align-items:flex-start">
      <div style="min-width:0">
        <div style="font-weight:700;color:#fb7185;margin-bottom:6px">Calculator error</div>
        <pre id="errorText" style="margin:0;white-space:pre-wrap;word-break:break-word;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace;font-size:12px;color:#e5e7eb"></pre>
      </div>
      <button id="errorClose" class="btn small" style="flex:0 0 auto;border-color:rgba(251,113,133,.65);background:rgba(251,113,133,.12)">Dismiss</button>
    </div>
  </div>

  <div class="container">
    <aside class="sidebar">
      <div class="row" style="align-items:flex-end">
        <div>
          <h2>Investment Calculator</h2>
          <div class="pill" title="Custom price projections, performance optimized, mobile-ready">v8.3 - enhanced investor view</div>
        </div>
        <button id="resetBtn" class="btn small danger" title="Reset everything to defaults">Reset</button>
      </div>

      <label>Choose Project</label>
      <select id="project">
        <option>UAE: Operation SandHash 2</option>
      </select>

      <label>Choose Miners</label>
      <select id="minerModel">
        <option value="s21hyd" data-hash="335" data-power="5.36" data-capex="9600">Bitmain Antminer S21 Hyd 335T</option>
        <option value="s19pro" data-hash="110" data-power="3.25" data-capex="1600">Bitmain Antminer S19 Pro</option>
        <option value="s19" data-hash="95" data-power="3.25" data-capex="1100">Bitmain Antminer S19</option>
      </select>

      <label>Choose Currency</label>
      <select id="currency">
        <option value="USD">USD</option>
        <option value="EUR">EUR</option>
      </select>

      <label>USD ‚Üí EUR FX Rate (for display)</label>
      <div class="price-row">
        <input type="number" id="fxRate" value="0.92" step="0.0001" min="0" title="Multiply USD amounts by this rate when displaying EUR">
        <button class="btn refresh-btn" id="refreshFx" title="Refresh USD‚ÜíEUR FX rate">üîÑ</button>
      </div>
      <div class="note">If refresh fails (CORS on file://), type the rate manually. Calculations run in USD internally; EUR is a display conversion.</div>

      <label>Miners</label>
      <div class="counter">
        <button class="btn" id="minerMinus">-</button>
        <input type="number" id="minerCount" value="138" min="1" step="1">
        <button class="btn" id="minerPlus">+</button>
      </div>
      <p class="capex"><span id="currencySymbol">$</span><span id="totalCapex">0</span> (Hardware Capex)</p>

      <label>Hold Period (months)</label>
      <div class="slider-wrap">
        <input type="range" id="holdMonthsRange" min="1" max="120" step="1" value="60" data-bind="holdMonths">
        <input type="number" id="holdMonths" min="1" max="120" step="1" value="60">
      </div>

      <label>Scenario</label>
      <div class="scenarios">
        <button class="btn scenario-btn" data-val="bear">Bear</button>
        <button class="btn scenario-btn active" data-val="base">Base</button>
        <button class="btn scenario-btn" data-val="bull">Bull</button>
      </div>


      <label>Current Bitcoin Price (Month 1 only)</label>
      <div class="price-row">
        <input type="text" id="currentBtcPrice" readonly>
        <button class="btn refresh-btn" id="refreshPrice" title="Refresh BTC spot price">üîÑ</button>
      </div>
      <div class="note">
        Uses Coinbase ‚Äúspot price‚Äù endpoint when available (may fail if your browser blocks CORS on file:// pages). If it fails, type a price below. 
      </div>

      <label>Manual BTC Price Override (USD)</label>
      <input type="number" id="btcOverride" value="" placeholder="(optional) e.g. 105000" step="100" min="0">

      <!-- Custom Price Projection Panel -->
      <div class="price-projection-panel" id="priceProjectionPanel">
        <div class="price-projection-header" id="priceProjectionHeader">
          <h4>Price Projections (5-Year)</h4>
          <span class="price-projection-toggle">‚ñº</span>
        </div>
        <div class="price-projection-content">
          <div class="price-model-selector">
            <button class="price-model-btn active" data-mode="cycle" title="Uses drift + amplitude cycle model">Cycle Model</button>
            <button class="price-model-btn" data-mode="custom" title="Set custom annual price changes">Custom Annual</button>
          </div>

          <div id="customPriceControls" style="display:none">
            <div class="price-presets">
              <button class="price-preset-btn" data-preset="bull" title="+40%, +30%, +25%, +20%, +15%">Bull</button>
              <button class="price-preset-btn" data-preset="base" title="+15%, +10%, +8%, +5%, +5%">Base</button>
              <button class="price-preset-btn" data-preset="bear" title="-10%, -5%, 0%, +5%, +10%">Bear</button>
              <button class="price-preset-btn active" data-preset="custom" title="Enter your own values">Custom</button>
            </div>

            <div class="year-row" style="margin-bottom:4px">
              <span class="year-label" style="font-size:10px;color:var(--muted)">Year</span>
              <span style="font-size:10px;color:var(--muted);text-align:center">Change %</span>
              <span style="font-size:10px;color:var(--muted);text-align:right">Price (USD)</span>
            </div>

            <div class="year-row">
              <span class="year-label">Year 1</span>
              <input type="number" class="year-input" id="priceY1" value="15" min="-90" max="500" step="1" placeholder="%">
              <span class="year-price" id="priceY1Display">$0</span>
            </div>
            <div class="year-row">
              <span class="year-label">Year 2</span>
              <input type="number" class="year-input" id="priceY2" value="10" min="-90" max="500" step="1" placeholder="%">
              <span class="year-price" id="priceY2Display">$0</span>
            </div>
            <div class="year-row">
              <span class="year-label">Year 3</span>
              <input type="number" class="year-input" id="priceY3" value="8" min="-90" max="500" step="1" placeholder="%">
              <span class="year-price" id="priceY3Display">$0</span>
            </div>
            <div class="year-row">
              <span class="year-label">Year 4</span>
              <input type="number" class="year-input" id="priceY4" value="5" min="-90" max="500" step="1" placeholder="%">
              <span class="year-price" id="priceY4Display">$0</span>
            </div>
            <div class="year-row">
              <span class="year-label">Year 5</span>
              <input type="number" class="year-input" id="priceY5" value="5" min="-90" max="500" step="1" placeholder="%">
              <span class="year-price" id="priceY5Display">$0</span>
            </div>

            <div class="price-sparkline">
              <canvas id="priceSparkline"></canvas>
            </div>
            <div class="sparkline-labels">
              <span>Start</span>
              <span>Year 5</span>
            </div>
          </div>

          <div id="cycleModelNote" class="note" style="margin-top:8px">
            Price follows a cycle model with <strong id="cycleNoteDetails">20% drift, ¬±60% amplitude</strong>. Switch to Custom Annual for explicit year-by-year control.
          </div>
        </div>
      </div>

      <div class="divider"></div>

      <div id="assumptions"></div>
      <h3 style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">Advanced Assumptions (sliders)<button id="toggleAdvanced" class="btn small ghost" style="margin-left:8px;">Show</button></h3><div id="advancedAssumptions" style="display:none;">

      <label title="Long-term annual drift for the BTC cycle model (trend component).">BTC Price Drift (annual, %)</label>
      <div class="slider-wrap">
        <input type="range" id="priceDriftRange" min="-20" max="60" step="1" value="20" data-bind="priceDrift">
        <input type="number" id="priceDrift" value="20" step="1" min="-90" max="200">
      </div>

      <label title="Cycle swing size around the drift trend. Higher amplitude = deeper drawdowns and higher peaks.">BTC Cycle Amplitude (+/- %)</label>
      <div class="slider-wrap">
        <input type="range" id="priceCycleAmpRange" min="0" max="150" step="1" value="60" data-bind="priceCycleAmp">
        <input type="number" id="priceCycleAmp" value="60" step="1" min="0" max="200">
      </div>

      <label title="Approximate length of a full BTC price cycle in months.">BTC Cycle Length (months)</label>
      <div class="slider-wrap">
        <input type="range" id="priceCycleMonthsRange" min="24" max="72" step="1" value="48" data-bind="priceCycleMonths">
        <input type="number" id="priceCycleMonths" value="48" step="1" min="12" max="96">
      </div>

      <label title="Aligns the cycle phase to the most recent halving date.">Halving Anchor Date</label>
      <input type="date" id="halvingAnchor" value="2024-04-20">
      <div class="note">Used to align the price cycle phase to the most recent halving.</div>


      <label>Unit Miner Cost (Capex per miner)</label>
      <div class="slider-wrap">
        <input type="range" id="unitCapexRange" min="200" max="12000" step="50" value="9600" data-bind="unitCapex">
        <input type="number" id="unitCapex" value="9600" step="50" min="0">
      </div>

      <label>Power Cost (USD/kWh)</label>
      <div class="slider-wrap">
        <input type="range" id="powerCostRange" min="0.00" max="0.20" step="0.001" value="0.05" data-bind="powerCost">
        <input type="number" id="powerCost" value="0.05" step="0.001" min="0">
      </div>

      <label>Hashrate per Miner (TH/s)</label>
      <div class="slider-wrap">
        <input type="range" id="hashrateRange" min="50" max="600" step="1" value="335" data-bind="hashratePerMiner">
        <input type="number" id="hashratePerMiner" value="335" step="1" min="1">
      </div>

      <label>Power per Miner (kW)</label>
      <div class="slider-wrap">
        <input type="range" id="powerPerMinerRange" min="1.0" max="10.0" step="0.01" value="5.36" data-bind="powerPerMiner">
        <input type="number" id="powerPerMiner" value="5.36" step="0.01" min="0">
      </div>

      <label>Network Hashrate (EH/s)</label>
      <div class="slider-wrap">
        <input type="range" id="networkHashRange" min="300" max="2000" step="1" value="1057" data-bind="networkHashrateEH">
        <input type="number" id="networkHashrateEH" value="1057" step="1" min="1" title="Current network hashrate in EH/s">
      </div>
      <div class="row" style="gap:8px; align-items:center; margin-top:6px">
        <button class="btn small" id="refreshHashrate" title="Refresh network hashrate from Blockchain.com">Fetch Network Hash</button>
        <div class="muted" style="font-size:12px">Uses Blockchain.com hash-rate data.</div>
      </div>
      <div class="muted" id="hashrateStatus" style="font-size:12px; margin-top:6px"></div>

      <label>Uptime (%)</label>
      <div class="slider-wrap">
        <input type="range" id="uptimeRange" min="80" max="100" step="0.1" value="97" data-bind="uptime">
        <input type="number" id="uptime" value="97" step="0.1" min="0" max="100">
      </div>

      <label>Pool Fee (%)</label>
      <div class="slider-wrap">
        <input type="range" id="poolFeeRange" min="0" max="5" step="0.1" value="1.5" data-bind="poolFee">
        <input type="number" id="poolFee" value="1.5" step="0.1" min="0">
      </div>

      <label>Hosting Fee (% of revenue)</label>
      <div class="slider-wrap">
        <input type="range" id="hostingFeeRange" min="0" max="10" step="0.1" value="1" data-bind="hostingFee">
        <input type="number" id="hostingFee" value="1" step="0.1" min="0">
      </div>

      <label>Management Fee (% of revenue)</label>
      <div class="slider-wrap">
        <input type="range" id="managementFeeRange" min="0" max="10" step="0.1" value="0.5" data-bind="managementFee">
        <input type="number" id="managementFee" value="0.5" step="0.1" min="0">
      </div>

      <label>Insurance Fee (% of revenue)</label>
      <div class="slider-wrap">
        <input type="range" id="insuranceFeeRange" min="0" max="10" step="0.1" value="0.5" data-bind="insuranceFee">
        <input type="number" id="insuranceFee" value="0.5" step="0.1" min="0">
      </div>

      <label>Repair Reserve (% of capex / yr)</label>
      <div class="slider-wrap">
        <input type="range" id="repairRange" min="0" max="5" step="0.1" value="0" data-bind="repairReserve">
        <input type="number" id="repairReserve" value="0" step="0.1" min="0">
      </div>
      <label>ASIC Degradation (%/yr)</label>
      <div class="slider-wrap">
        <input type="range" id="degradeRange" min="0" max="30" step="0.1" value="0" data-bind="degradation">
        <input type="number" id="degradation" value="0" step="0.1" min="0">
      </div>

      <label>Difficulty / Network Growth (%/yr)</label>
      <div class="slider-wrap">
        <input type="range" id="diffRange" min="-10" max="50" step="0.5" value="15" data-bind="difficultyGrowth">
        <input type="number" id="difficultyGrowth" value="15" step="0.5">
      </div>

      <label>Resale Value (% of capex at end)</label>
      <div class="slider-wrap">
        <input type="range" id="resaleRange" min="0" max="100" step="1" value="0" data-bind="resaleValue">
        <input type="number" id="resaleValue" value="0" step="1" min="0" max="100">
      </div>

      <label>Reinvest Net BTC to Cover OPEX</label>
      <div class="row" style="margin-top:8px">
        <input type="checkbox" id="reinvestBtc" style="transform:scale(1.15); width:auto; margin:0 8px 0 0">
        <div class="muted" style="font-size:12px">
          If checked, mined BTC is sold as needed to pay OPEX (reducing ending BTC).
        </div>
      </div>

      </div>
<div class="divider"></div>

      <h3>Assumptions</h3>
      <button id="toggleAssumptions" class="btn small ghost">Show Assumptions</button>
      <div id="assumptionsPanel" style="display:none; margin-top:10px">
        <p class="muted" style="margin:6px 0"><strong>Current BTC Price:</strong> <span id="assumptionsBtcPrice">‚Äî</span></p>
        <p class="muted" style="margin:6px 0"><strong>Block Reward:</strong> 3.125 BTC (halving in month 28)</p>
        <p class="muted" style="margin:6px 0"><strong>BTC Price Model:</strong> Cycle-based (drift + amplitude)</p>
        <ul class="muted" style="margin:6px 0 0 18px">
          <li>Bear: 5% drift, 45% amplitude</li>
          <li>Base: 20% drift, 60% amplitude</li>
          <li>Bull: 35% drift, 80% amplitude</li>
        </ul>
        <p class="muted" style="margin:8px 0"><strong>Last updated:</strong> <span id="timestamp"></span></p>
      </div>

      <div class="sticky-actions">
        <div class="row">
          <button class="btn primary" id="shareBtn">Share Scenario</button>
          <button class="btn" id="exportBtn">Download Data (CSV)</button>
          <div id="onepager"></div>
          <button class="btn" id="exportHtmlBtn">Download 1-Page Report (HTML)</button>
          <button class="btn" id="exportPdfBtn">Download 1-Page Report (PDF)</button>
        </div>
        <div class="note">
          Tip: If ‚ÄúShare Scenario‚Äù link is long, it‚Äôs because it includes all assumptions as URL params.
        </div>
      </div>
    </aside>

    <main class="main">
      <div class="tabs">
        <button class="btn tab-btn active" data-tab="executive">Executive View</button>
        <button class="btn tab-btn" data-tab="overview">Overview</button>
        <button class="btn tab-btn" data-tab="cashflow">Cash Flow</button>
        <button class="btn tab-btn" data-tab="sensitivity">Sensitivity</button>
        <button class="btn tab-btn" data-tab="montecarlo">Monte Carlo</button>
              </div>
      <div class="row" style="align-items:center; justify-content:space-between; margin:10px 0 14px">
        <div class="muted" style="font-size:12px">As of <span id="timestamp2">‚Äî</span></div>
      </div>

      <section id="executive" class="tab-content active">
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:14px">
          <h2 style="margin:0">Investment Summary</h2>
          <div class="pill" style="font-size:10px">
            <span id="execTimestamp">‚Äî</span>
          </div>
        </div>

        <!-- Hero Metrics -->
        <div class="exec-hero">
          <div class="hero-metric highlight" id="heroMoic" title="Multiple on invested capital using terminal BTC value (excludes ASIC resale)">
            <div class="label">Return Multiple</div>
            <div class="value"><span id="execMoic">‚Äî</span>x</div>
            <div class="subtext">MOIC (BTC value only)</div>
          </div>
          <div class="hero-metric" id="heroIrr" title="Annualized Internal Rate of Return, pre-tax">
            <div class="label">Annualized Return</div>
            <div class="value"><span id="execIrr">‚Äî</span>%</div>
            <div class="subtext">IRR (pre-tax)</div>
          </div>
          <div class="hero-metric" id="heroPayback" title="First month where cumulative net value turns positive">
            <div class="label">Capital Recovery</div>
            <div class="value"><span id="execPayback">‚Äî</span></div>
            <div class="subtext" id="paybackSubtext">months to payback</div>
          </div>
        </div>

        <!-- Investment Scorecard -->
        <div class="exec-scorecard">
          <div class="scorecard-header">
            <h3>Investment Scorecard</h3>
            <div class="scorecard-grade" id="overallGrade">
              <span id="gradeIcon">‚óâ</span>
              <span id="gradeText">Calculating...</span>
            </div>
          </div>
          <div class="scorecard-items">
            <div class="scorecard-item">
              <div class="scorecard-icon" id="scoreMoicIcon">‚óâ</div>
              <div class="scorecard-text">
                <div class="title">Return Multiple</div>
                <div class="result" id="scoreMoicText">‚Äî</div>
              </div>
            </div>
            <div class="scorecard-item">
              <div class="scorecard-icon" id="scorePaybackIcon">‚óâ</div>
              <div class="scorecard-text">
                <div class="title">Payback Period</div>
                <div class="result" id="scorePaybackText">‚Äî</div>
              </div>
            </div>
            <div class="scorecard-item">
              <div class="scorecard-icon" id="scoreCostIcon">‚óâ</div>
              <div class="scorecard-text">
                <div class="title">Cost per BTC</div>
                <div class="result" id="scoreCostText">‚Äî</div>
              </div>
            </div>
            <div class="scorecard-item">
              <div class="scorecard-icon" id="scoreEdgeIcon">‚óâ</div>
              <div class="scorecard-text">
                <div class="title">Mining Advantage</div>
                <div class="result" id="scoreEdgeText">‚Äî</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Mining vs Buying Comparison -->
        <h3 style="font-size:13px;margin:16px 0 10px">Mining vs. Buying Bitcoin</h3>
        <div class="exec-comparison">
          <div class="compare-card" id="miningCard">
            <div class="method">‚õèÔ∏è Mining</div>
            <div class="btc-amount" id="execMiningBtc">0.0000</div>
            <div class="btc-label">BTC acquired</div>
            <div class="fiat-value"><span id="execSym1">$</span><span id="execMiningValue">0</span></div>
          </div>
          <div class="compare-vs">VS</div>
          <div class="compare-card" id="buyingCard">
            <div class="method">üíµ DCA Buying</div>
            <div class="btc-amount" id="execDcaBtc">0.0000</div>
            <div class="btc-label">BTC acquired</div>
            <div class="fiat-value"><span id="execSym2">$</span><span id="execDcaValue">0</span></div>
          </div>
        </div>

        <!-- Advantage Callout -->
        <div class="exec-advantage" id="execAdvantage">
          <div class="adv-label">Mining Advantage</div>
          <div class="adv-value" id="execAdvValue">+0.0000 BTC</div>
          <div class="adv-detail" id="execAdvDetail">Same capital ‚Üí more Bitcoin via mining</div>
        </div>

        <!-- 5-Year Projection -->
        <h3 style="font-size:13px;margin:16px 0 10px">5-Year BTC Accumulation</h3>
        <div class="exec-timeline" id="execTimeline">
          <div class="timeline-year"><div class="yr">Y1</div><div class="btc">‚Äî</div><div class="val">‚Äî</div></div>
          <div class="timeline-year"><div class="yr">Y2</div><div class="btc">‚Äî</div><div class="val">‚Äî</div></div>
          <div class="timeline-year"><div class="yr">Y3</div><div class="btc">‚Äî</div><div class="val">‚Äî</div></div>
          <div class="timeline-year"><div class="yr">Y4</div><div class="btc">‚Äî</div><div class="val">‚Äî</div></div>
          <div class="timeline-year"><div class="yr">Y5</div><div class="btc">‚Äî</div><div class="val">‚Äî</div></div>
        </div>

        <!-- Chart -->
        <h3 class="graph-title" style="margin-top:16px">Cumulative Net Value</h3>
        <div class="chart-box"><canvas id="execNetValueChart"></canvas></div>

        <div class="divider"></div>

        <!-- Key Assumptions -->
        <div class="exec-assumptions">
          <h4>Key Assumptions</h4>
          <div class="assumption-grid" id="execAssumpSummary">
            <div class="assumption-item"><span class="label">Miners:</span> <span class="value">‚Äî</span></div>
            <div class="assumption-item"><span class="label">Capex:</span> <span class="value">‚Äî</span></div>
            <div class="assumption-item"><span class="label">Power:</span> <span class="value">‚Äî</span></div>
            <div class="assumption-item"><span class="label">Start Price:</span> <span class="value">‚Äî</span></div>
            <div class="assumption-item"><span class="label">Hold Period:</span> <span class="value">‚Äî</span></div>
            <div class="assumption-item"><span class="label">Price Model:</span> <span class="value">‚Äî</span></div>
          </div>
        </div>

        <div class="note" style="margin-top:12px;text-align:center">
          Open <strong>Overview</strong> for full outputs ‚Ä¢ <strong>Cash Flow</strong> for monthly bridge ‚Ä¢ <strong>Sensitivity</strong> for stress tests
        </div>
      </section>


      <section id="overview" class="tab-content">
        <h2>Outputs</h2>

        <div class="tiles">
          <div class="tile" title="Sum of (BTC mined each month √ó monthly price)">
            <h3>Cumulative Revenue</h3>
            <p><span id="currencySymbol1">$</span><span id="revenue">0</span></p>
          </div>
          <div class="tile" title="Capex + all OPEX components over hold period">
            <h3>Cumulative Costs</h3>
            <p><span id="currencySymbol2">$</span><span id="costs">0</span></p>
          </div>
          <div class="tile" title="Revenue ‚àí OPEX ‚àí Capex + resale value">
            <h3>Cumulative Net Cash Flow</h3>
            <p><span id="currencySymbol3">$</span><span id="netCash">0</span></p>
          </div>
        </div>

        <div class="tiles">
          <div class="tile" title="Internal Rate of Return on net value (terminal BTC + resale included), pre-tax">
            <h3>IRR (pre-tax)</h3>
            <p><span id="irr">0</span>%</p>
          </div>
          <div class="tile" title="Multiple on invested capital, using ending value of held BTC + resale value vs total cash invested">
            <h3>MOIC</h3>
            <p><span id="moic">0</span>x</p>
          </div>
          <div class="tile" title="BTC held at the end (depends on reinvest toggle)">
            <h3>Ending BTC</h3>
            <p><span id="btcMined">0</span></p>
          </div>
        </div>

        <h3 class="graph-title">Bitcoin Mining Profitability (Revenue, Profit, Electricity, Cumulative)</h3>
        <div class="chart-box"><canvas id="profitabilityChart"></canvas></div>

        <div class="divider"></div>

        <h3>Yearly BTC Value (held BTC √ó price)</h3>
        <div id="yearly" class="yearly-tiles"></div>

        <div class="divider"></div>

        <h3>Buying DCA vs Mining BTC</h3>
        <div class="comparison" title="DCA: Same cash outflows timing (capex upfront + out-of-pocket OPEX each month) into BTC at monthly prices. Mining: Ending BTC from mining after OPEX choice.">
          <div class="tile">
            <h4>Buying (DCA)</h4>
            <p>BTC: <span id="dcaBtc">0</span></p>
            <div class="muted"><span id="currencySymbol5">$</span><span id="dcaValue">0</span></div>
          </div>
          <div class="tile">
            <h4>Mining</h4>
            <p>BTC: <span id="miningBtc">0</span></p>
            <div class="muted"><span id="currencySymbol6">$</span><span id="miningValue">0</span></div>
          </div>
        </div>
      </section>

      <section id="cashflow" class="tab-content">
        <h2>Detailed Cash Flow Bridge</h2>
        <div class="note" style="margin:8px 0 12px">
          Note: ‚ÄúRevenue (USD)‚Äù is net BTC √ó monthly price. If ‚ÄúReinvest BTC‚Äù is checked, some BTC may be sold to cover OPEX (reducing BTC held). The last column shows cumulative net value: -capex - cash OPEX + (BTC held √ó price).
        </div>
        <div class="row" style="align-items:center; justify-content:space-between; margin:10px 0 8px">
          <div class="muted" id="cashflowViewLabel">View: Monthly</div>
          <button class="btn small" id="toggleCashflowView" title="Toggle monthly vs annual summary">Switch to Annual Summary</button>
        </div>
        <div class="table-scroll" aria-label="Scrollable cash flow table"><table id="cashflowTable">
          <thead>
            <tr>
              <th>Month</th>
              <th>Gross BTC</th>
              <th>- Pool Fee</th>
                            <th>Net BTC</th>
              <th>BTC Price</th>
              <th>Revenue (USD)</th>
              <th>- Power</th>
              <th>- Hosting</th>
              <th>- Mgmt</th>
              <th>- Insurance</th>
              <th>- Repairs</th>
              <th>Net Cash (USD)</th>
              <th>Cum. Net Value</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table></div>
      </section>

      <section id="sensitivity" class="tab-content">
        <h2>Sensitivity Analysis</h2>
        <p class="muted" style="margin-bottom:12px">How MOIC changes with different BTC price and difficulty growth assumptions. Your current settings are highlighted.</p>

        <div class="table-scroll" style="max-height:none">
        <table id="sensitivityTable">
          <thead>
            <tr>
              <th style="text-align:left">BTC Price</th>
              <th>Diff +5%/yr</th>
              <th>Diff +15%/yr</th>
              <th>Diff +25%/yr</th>
              <th>Diff +35%/yr</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
        </div>

        <div class="divider"></div>

        <h3 style="margin-top:14px">Power Cost Sensitivity</h3>
        <p class="muted" style="margin-bottom:10px">Impact of electricity price on returns (at current BTC price assumptions).</p>
        <table id="powerSensitivityTable">
          <thead>
            <tr>
              <th style="text-align:left">Power ($/kWh)</th>
              <th>MOIC</th>
              <th>Monthly OPEX</th>
              <th>Breakeven BTC</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>

        <p class="note" style="margin-top:12px">
          <strong>Reading this table:</strong> MOIC > 1.0x means profitable. Higher difficulty = more competition = lower returns.
          Lower BTC price = less revenue. Green cells indicate MOIC > 1.5x, red indicates MOIC < 1.0x.
        </p>
      </section>

      <section id="montecarlo" class="tab-content">
        <h2>Monte Carlo Simulation (1,000 runs)</h2>
        <p class="muted">Cycle drift/amplitude and difficulty growth are randomized around the selected scenario; this is a lightweight ‚Äúsanity check,‚Äù not a trading model.</p>
        <div class="tiles" style="grid-template-columns:repeat(3,minmax(0,1fr))">
          <div class="tile">
            <h3>Prob. MOIC &gt; 1.5x</h3>
            <p><span id="probMoic">‚Äî</span>%</p>
          </div>
          <div class="tile">
            <h3>Prob. break-even by month 18</h3>
            <p><span id="probBreakeven">‚Äî</span>%</p>
          </div>
          <div class="tile">
            <h3>Avg. ending BTC</h3>
            <p><span id="avgEndingBtc">‚Äî</span></p>
          </div>
        </div>
        <button class="btn primary" id="rerunMC" style="margin-top:10px">Re-run Monte Carlo</button>
        <div class="mc-progress" id="mcProgress" style="display:none">
          <div class="mc-progress-bar" id="mcProgressBar"></div>
        </div>
      </section>
</main>
  </div>

<script>
const _structuredClone = (obj) => {
  try { return structuredClone(obj); }
  catch { return JSON.parse(JSON.stringify(obj)); }
};

/**
 * Pantheon Mining Calculator v8.1 - Performance & Polish Edition
 *
 * Architecture:
 * - model(): Pure computation function, memoized for performance
 * - render(): Updates DOM from model output
 * - recalc(): Debounced orchestrator that ties model -> render
 * - Monte Carlo: Runs in batches with progress feedback
 *
 * Performance Features:
 * - Model computation caching (cache invalidated on input change)
 * - Batched Monte Carlo with UI updates every 100 runs
 * - Optimized chart updates (data swap, not recreate)
 * - RequestAnimationFrame for smooth renders
 */

// ========== PERFORMANCE: Computation Cache ==========
const modelCache = {
  key: null,
  result: null,
  hits: 0,
  misses: 0
};

function getModelCacheKey() {
  // Create a cache key from all inputs that affect model output
  return JSON.stringify({
    mc: state.minerCount,
    hm: state.holdMonths,
    sc: state.scenario,
    bo: state.btcOverride,
    // Price model mode and parameters
    priceModel: state.priceModel,
    py1: state.priceY1,
    py2: state.priceY2,
    py3: state.priceY3,
    py4: state.priceY4,
    py5: state.priceY5,
    pd: state.priceDrift,
    pa: state.priceCycleAmp,
    pm: state.priceCycleMonths,
    ha: state.halvingAnchor,
    uc: state.unitCapex,
    pc: state.powerCost,
    hp: state.hashratePerMiner,
    pp: state.powerPerMiner,
    nh: state.networkHashrateEH,
    ut: state.uptime,
    pf: state.poolFee,
    hf: state.hostingFee,
    mf: state.managementFee,
    if: state.insuranceFee,
    rr: state.repairReserve,
    dg: state.degradation,
    df: state.difficultyGrowth,
    rv: state.resaleValue,
    rb: state.reinvestBtc,
    bp: btcSpotUSD
  });
}

function getCachedModel() {
  const key = getModelCacheKey();
  if (modelCache.key === key && modelCache.result) {
    modelCache.hits++;
    return modelCache.result;
  }
  modelCache.misses++;
  const result = model();
  modelCache.key = key;
  modelCache.result = result;
  return result;
}

function invalidateModelCache() {
  modelCache.key = null;
  modelCache.result = null;
}

// ========== INPUT VALIDATION ==========
const validationRules = {
  minerCount: { min: 1, max: 100000, warn: { min: 10, max: 10000 }, label: 'Miners' },
  holdMonths: { min: 1, max: 120, warn: { min: 12 }, label: 'Hold Period' },
  uptime: { min: 50, max: 100, warn: { min: 90, max: 99 }, label: 'Uptime' },
  powerCost: { min: 0, max: 0.50, warn: { min: 0.02, max: 0.12 }, label: 'Power Cost' },
  difficultyGrowth: { min: -20, max: 100, warn: { min: 5, max: 40 }, label: 'Difficulty Growth' },
  networkHashrateEH: { min: 100, max: 5000, warn: { min: 500 }, label: 'Network Hashrate' }
};

function validateInput(id, value) {
  const rules = validationRules[id];
  if (!rules) return { valid: true };

  const num = Number(value);
  if (!Number.isFinite(num)) {
    return { valid: false, type: 'error', message: `${rules.label}: Enter a valid number` };
  }
  if (num < rules.min || num > rules.max) {
    return { valid: false, type: 'error', message: `${rules.label}: Must be ${rules.min}‚Äì${rules.max}` };
  }
  if (rules.warn) {
    if (rules.warn.min !== undefined && num < rules.warn.min) {
      return { valid: true, type: 'warning', message: `${rules.label}: ${num} is below typical range (${rules.warn.min}+)` };
    }
    if (rules.warn.max !== undefined && num > rules.warn.max) {
      return { valid: true, type: 'warning', message: `${rules.label}: ${num} is above typical range (‚â§${rules.warn.max})` };
    }
  }
  return { valid: true };
}

function applyValidation(inputEl, validation) {
  inputEl.classList.remove('warning', 'error');
  const existingMsg = inputEl.parentElement.querySelector('.validation-msg');
  if (existingMsg) existingMsg.remove();

  if (validation.type === 'warning') {
    inputEl.classList.add('warning');
    const msg = document.createElement('div');
    msg.className = 'validation-msg warning';
    msg.textContent = validation.message;
    inputEl.parentElement.appendChild(msg);
  } else if (validation.type === 'error') {
    inputEl.classList.add('error');
    const msg = document.createElement('div');
    msg.className = 'validation-msg error';
    msg.textContent = validation.message;
    inputEl.parentElement.appendChild(msg);
  }
}

// ========== LOADING STATE MANAGEMENT ==========
function setLoading(element, isLoading) {
  if (isLoading) {
    element.classList.add('loading');
    element.disabled = true;
  } else {
    element.classList.remove('loading');
    element.disabled = false;
  }
}

// ========== PERFORMANCE TIMING ==========
let lastRenderTime = 0;
function updatePerfIndicator() {
  const indicator = document.getElementById('perfIndicator');
  if (indicator && lastRenderTime > 0) {
    const cacheRatio = modelCache.hits + modelCache.misses > 0
      ? Math.round(100 * modelCache.hits / (modelCache.hits + modelCache.misses))
      : 0;
    indicator.textContent = `Render: ${lastRenderTime}ms | Cache: ${cacheRatio}%`;
  }
}

// ========== UI SYNC HELPERS ==========
/**
 * Synchronizes a number input with its paired range slider.
 * @param {string} inputId - The ID of the number input element
 * @param {string} rangeId - The ID of the range slider element
 * @param {number|string} value - The value to set on both elements
 */
function syncInputRange(inputId, rangeId, value) {
  const input = document.getElementById(inputId);
  const range = document.getElementById(rangeId);
  if (input) input.value = value;
  if (range) range.value = value;
}

const DEFAULTS = {
  project: "UAE: Operation SandHash 2",
  minerModel: "s21hyd",
  currency: "USD",
  fxRate: 0.92,
  minerCount: 138,
  holdMonths: 60,
  scenario: "base",
  investorMode: false,
  advancedUnlocked: true,
  cashflowView: "monthly",
  btcOverride: "",
  // Price Model: "cycle" (drift+amplitude) or "custom" (explicit annual %)
  priceModel: "cycle",
  // Custom annual price changes (%)
  priceY1: 15,
  priceY2: 10,
  priceY3: 8,
  priceY4: 5,
  priceY5: 5,
  pricePreset: "custom",
  // Cycle model parameters
  priceDrift: 20,
  priceCycleAmp: 60,
  priceCycleMonths: 48,
  halvingAnchor: "2024-04-20",
  unitCapex: 9600,
  powerCost: 0.05,
  hashratePerMiner: 335,
  powerPerMiner: 5.36,
  networkHashrateEH: 1057,
  uptime: 97,
  poolFee: 1.5,
  hostingFee: 1,
  managementFee: 0.5,
  insuranceFee: 0.5,
  repairReserve: 0,
  degradation: 0,
  difficultyGrowth: 20,
  resaleValue: 0,
  reinvestBtc: false,
};

const SCENARIOS = {
  bear: { drift: 5, amp: 45 },
  base: { drift: 20, amp: 60 },
  bull: { drift: 35, amp: 80 },
};

// Custom Annual Price Presets (% change per year)
const PRICE_PRESETS = {
  bull: { y1: 40, y2: 30, y3: 25, y4: 20, y5: 15, label: "Bull Case" },
  base: { y1: 15, y2: 10, y3: 8, y4: 5, y5: 5, label: "Base Case" },
  bear: { y1: -10, y2: -5, y3: 0, y4: 5, y5: 10, label: "Bear Case" },
  custom: { y1: 15, y2: 10, y3: 8, y4: 5, y5: 5, label: "Custom" }
};

const UI = {
  minerModel: document.getElementById("minerModel"),
  currency: document.getElementById("currency"),
  investorMode: document.getElementById("investorMode"),
  fxRate: document.getElementById("fxRate"),
  refreshFx: document.getElementById("refreshFx"),
  refreshHashrate: document.getElementById("refreshHashrate"),
  hashrateStatus: document.getElementById("hashrateStatus"),
  minerCount: document.getElementById("minerCount"),
  minerMinus: document.getElementById("minerMinus"),
  minerPlus: document.getElementById("minerPlus"),
  holdMonths: document.getElementById("holdMonths"),
  holdMonthsRange: document.getElementById("holdMonthsRange"),
  currentBtcPrice: document.getElementById("currentBtcPrice"),
  btcOverride: document.getElementById("btcOverride"),
  priceDrift: document.getElementById("priceDrift"),
  priceCycleAmp: document.getElementById("priceCycleAmp"),
  priceCycleMonths: document.getElementById("priceCycleMonths"),
  halvingAnchor: document.getElementById("halvingAnchor"),
  refreshPrice: document.getElementById("refreshPrice"),

  // Custom Price Projection
  priceProjectionPanel: document.getElementById("priceProjectionPanel"),
  priceProjectionHeader: document.getElementById("priceProjectionHeader"),
  customPriceControls: document.getElementById("customPriceControls"),
  cycleModelNote: document.getElementById("cycleModelNote"),
  cycleNoteDetails: document.getElementById("cycleNoteDetails"),
  priceY1: document.getElementById("priceY1"),
  priceY2: document.getElementById("priceY2"),
  priceY3: document.getElementById("priceY3"),
  priceY4: document.getElementById("priceY4"),
  priceY5: document.getElementById("priceY5"),
  priceY1Display: document.getElementById("priceY1Display"),
  priceY2Display: document.getElementById("priceY2Display"),
  priceY3Display: document.getElementById("priceY3Display"),
  priceY4Display: document.getElementById("priceY4Display"),
  priceY5Display: document.getElementById("priceY5Display"),
  priceSparkline: document.getElementById("priceSparkline"),
  toggleAssumptions: document.getElementById("toggleAssumptions"),
  assumptionsPanel: document.getElementById("assumptionsPanel"),
  assumptionsBtcPrice: document.getElementById("assumptionsBtcPrice"),
  timestamp: document.getElementById("timestamp"),
  resetBtn: document.getElementById("resetBtn"),

  // Advanced number inputs (paired with sliders via data-bind)
  unitCapex: document.getElementById("unitCapex"),
  powerCost: document.getElementById("powerCost"),
  hashratePerMiner: document.getElementById("hashratePerMiner"),
  powerPerMiner: document.getElementById("powerPerMiner"),
  networkHashrateEH: document.getElementById("networkHashrateEH"),
  uptime: document.getElementById("uptime"),
  poolFee: document.getElementById("poolFee"),
  hostingFee: document.getElementById("hostingFee"),
  managementFee: document.getElementById("managementFee"),
  insuranceFee: document.getElementById("insuranceFee"),
  repairReserve: document.getElementById("repairReserve"),
  degradation: document.getElementById("degradation"),
  difficultyGrowth: document.getElementById("difficultyGrowth"),
  resaleValue: document.getElementById("resaleValue"),
  reinvestBtc: document.getElementById("reinvestBtc"),

  // Outputs
  currencySymbol: document.getElementById("currencySymbol"),
  totalCapex: document.getElementById("totalCapex"),
  revenue: document.getElementById("revenue"),
  costs: document.getElementById("costs"),
  netCash: document.getElementById("netCash"),
  irr: document.getElementById("irr"),
  moic: document.getElementById("moic"),
  btcMined: document.getElementById("btcMined"),
  yearly: document.getElementById("yearly"),
  dcaBtc: document.getElementById("dcaBtc"),
  dcaValue: document.getElementById("dcaValue"),
  miningBtc: document.getElementById("miningBtc"),
  miningValue: document.getElementById("miningValue"),
  cashflowTbody: document.querySelector("#cashflowTable tbody"),
  cashflowViewLabel: document.getElementById("cashflowViewLabel"),
  toggleCashflowView: document.getElementById("toggleCashflowView"),
  sensitivityTbody: document.querySelector("#sensitivityTable tbody"),
  powerSensitivityTbody: document.querySelector("#powerSensitivityTable tbody"),
  probMoic: document.getElementById("probMoic"),
  probBreakeven: document.getElementById("probBreakeven"),
  avgEndingBtc: document.getElementById("avgEndingBtc"),
  rerunMC: document.getElementById("rerunMC"),
  exportBtn: document.getElementById("exportBtn"),
  shareBtn: document.getElementById("shareBtn"),
  exportHtmlBtn: document.getElementById("exportHtmlBtn"),
  exportPdfBtn: document.getElementById("exportPdfBtn"),
};

let state = _structuredClone(DEFAULTS);


function setAdvancedEnabled(enabled){
  const panel = document.getElementById("advancedAssumptions");
  if(!panel) return;
  panel.querySelectorAll("input,select,textarea,button").forEach(el=>{
    // never disable the show/hide button
    if(el.id === "toggleAdvanced") return;
    el.disabled = !enabled;
  });
  panel.classList.toggle("is-locked", !enabled);
}

function applyInvestorMode(){
  const on = !!state.investorMode;
  document.body.classList.toggle("investor-mode", on);

  // Hide "deep" tabs in Investor Mode
  document.querySelectorAll('.tab-btn[data-tab="sensitivity"], .tab-btn[data-tab="montecarlo"]').forEach(btn=>{
    btn.style.display = on ? "none" : "";
  });

  // If user is currently on a hidden tab, bounce them back to Executive View
  const active = document.querySelector(".tab-btn.active");
  const activeTab = active?.dataset?.tab;
  if(on && (activeTab === "sensitivity" || activeTab === "montecarlo")){
    setTab("executive");
  }

  // Default Cash Flow view (only if unset)
  if(!state.cashflowView) state.cashflowView = on ? "annual" : "monthly";

  // Advanced Assumptions: locked by default in Investor Mode (unlockable)
  if(!on) state.advancedUnlocked = true;
  const panel = document.getElementById("advancedAssumptions");
  const btn = document.getElementById("toggleAdvanced");
  if(on && !state.advancedUnlocked){
    if(panel) panel.style.display = "none";
    if(btn) btn.textContent = "Unlock Advanced";
    setAdvancedEnabled(false);
  }else{
    setAdvancedEnabled(true);
    // keep whatever the panel is currently doing, but normalize button label
    if(btn && panel){
      btn.textContent = (panel.style.display === "none") ? "Show" : "Hide";
    }
  }
}

let btcSpotUSD = null;

// ---------- Helpers ----------
const clamp = (x, lo, hi) => Math.min(hi, Math.max(lo, x));
const round = (x, d=2) => Number.isFinite(x) ? Number(x.toFixed(d)) : 0;

function fmtMoney(x, currency="USD"){
  const n = Number.isFinite(x) ? x : 0;
  return Math.round(n).toLocaleString(undefined);
}
function fmtNum(x, d=3){
  return (Number.isFinite(x) ? x : 0).toFixed(d);
}
function symbolFor(cur){ return cur === "EUR" ? "‚Ç¨" : "$"; }

function fxRate(){
  // Internal model is USD. If user selects EUR, display = USD * fxRate.
  const r = Number(state.fxRate);
  return (Number.isFinite(r) && r > 0) ? r : 0.85;
}
function toDisplay(usd){
  const v = Number.isFinite(usd) ? usd : 0;
  return state.currency === "EUR" ? v * fxRate() : v;
}

// IRR (monthly) using binary search
function irrMonthly(cashflows){
  // need at least one negative and one positive
  let hasNeg=false, hasPos=false;
  for(const c of cashflows){ if(c<0) hasNeg=true; if(c>0) hasPos=true; }

  if(!hasNeg || !hasPos) return null;

  const npv = (rate) => cashflows.reduce((acc, c, i) => acc + c / Math.pow(1+rate, i), 0);

  let lo = -0.99, hi = 2.0; // -99% to +200% per month
  for(let iter=0; iter<80; iter++){
    const mid = (lo+hi)/2;
    const v = npv(mid);
    if (v > 0) lo = mid; else hi = mid;
  }
  return (lo+hi)/2;
}

function debounce(fn, ms=50){
  let t=null;
  return (...args) => { clearTimeout(t); t=setTimeout(()=>fn(...args), ms); };
}

// ---------- Visible error hook ----------
(function(){
  const banner = document.getElementById("errorBanner");
  const txt = document.getElementById("errorText");
  const close = document.getElementById("errorClose");
  if(close) close.addEventListener("click", ()=>{ if(banner) banner.style.display="none"; });
  function show(msg){
    if(!banner || !txt) return;
    txt.textContent = String(msg || "Unknown error");
    banner.style.display="block";
  }
  window.addEventListener("error", (e)=>{
    show((e?.message || "Error") + (e?.filename ? `\n${e.filename}:${e.lineno||0}:${e.colno||0}` : ""));
  });
  window.addEventListener("unhandledrejection", (e)=>{
    show("Unhandled promise rejection\n" + (e?.reason?.message || e?.reason || ""));
  });
})();


// Parse and apply query params for shareable scenarios
function loadFromQuery(){
  const qs = new URLSearchParams(location.search);
  if(!qs || [...qs.keys()].length === 0) return;
  for(const [k,v] of qs.entries()){
    if(!(k in DEFAULTS)) continue;
    if(typeof DEFAULTS[k] === "boolean") state[k] = (v === "1" || v === "true");
    else if(typeof DEFAULTS[k] === "number") state[k] = Number(v);
    else state[k] = v;
  }
}

// Put state into URL (Share Scenario)
async function shareScenario(){
  const qs = new URLSearchParams();
  for(const k of Object.keys(DEFAULTS)){
    const v = state[k];
    if(typeof v === "boolean") qs.set(k, v ? "1":"0");
    else qs.set(k, String(v));
  }
  const base = location.href.split("?")[0];
  const url = `${base}?${qs.toString()}`;
  try{
    await navigator.clipboard.writeText(url);
    UI.shareBtn.textContent = "Copied.";
    setTimeout(()=>UI.shareBtn.textContent="Share Scenario", 1200);
  }catch{
    prompt("Copy this link:", url);
  }
}

// CSV export
function exportCSV(rows){
  const header = Object.keys(rows[0] || {});
  const csv = [header.join(",")].concat(
    rows.map(r => header.map(h => `"${String(r[h] ?? "").replaceAll('"','""')}"`).join(","))
  ).join("\n");
  const blob = new Blob([csv], {type:"text/csv"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "pantheon_mining_cashflow.csv";
  document.body.appendChild(a);
  a.click();
  a.remove();
}

function buildOnePagerHtml(){
  const out = model();
  const sym = symbolFor(state.currency);
  const ts = new Date().toLocaleDateString('en-US', { year:'numeric', month:'long', day:'numeric' });
  const timeStr = new Date().toLocaleTimeString('en-US', { hour:'2-digit', minute:'2-digit' });

  // Try to embed the executive net value chart as an image
  let chartImg = "";
  const c = document.getElementById("execNetValueChart");
  try{
    if(c && c.toDataURL){
      chartImg = c.toDataURL("image/png");
    }
  }catch(e){ /* ignore */ }

  const irrVal = out.irrANoResale;
  const irrStr = irrVal === null ? "‚Äî" : `${fmtNum(irrVal*100,1)}%`;
  const moicVal = out.moicNoResale;
  const moicStr = `${fmtNum(moicVal,2)}x`;
  const paybackMonths = document.getElementById("execPayback")?.textContent || "‚Äî";

  // Calculate DCA comparison (same logic as recalc)
  let dcaBTC = 0;
  if(out.prices[0] > 0){
    dcaBTC += out.capex / out.prices[0];
  }
  for(let i = 0; i < out.rows.length; i++){
    const r = out.rows[i];
    const outOfPocket = r.NetCashUSD < 0 ? Math.abs(r.NetCashUSD) : 0;
    if(outOfPocket > 0 && out.prices[i] > 0){
      dcaBTC += outOfPocket / out.prices[i];
    }
  }
  const miningAdvantage = out.endingBTC - dcaBTC;
  const advPct = dcaBTC > 0 ? ((out.endingBTC / dcaBTC - 1) * 100) : 0;

  // Cost per BTC
  const costPerBtc = out.endingBTC > 0 ? (out.capex + out.totalOpex) / out.endingBTC : 0;

  // Determine grade
  let grade = 'Review';
  let gradeColor = '#94A3B8';
  if (moicVal >= 1.5 && paybackMonths !== "‚Äî" && parseInt(paybackMonths) <= 36) {
    grade = 'Excellent';
    gradeColor = '#10B981';
  } else if (moicVal >= 1.2) {
    grade = 'Good';
    gradeColor = '#3B82F6';
  } else if (moicVal >= 1.0) {
    grade = 'Fair';
    gradeColor = '#F59E0B';
  }

  // Price model description
  let priceModelDesc = '';
  if (state.priceModel === 'custom') {
    const preset = state.pricePreset !== 'custom' ? state.pricePreset.charAt(0).toUpperCase() + state.pricePreset.slice(1) : 'Custom';
    priceModelDesc = `Custom Annual (${preset})`;
  } else {
    priceModelDesc = `Cycle Model: ${state.priceDrift > 0 ? '+' : ''}${state.priceDrift.toFixed(0)}%/yr drift`;
  }

  // 5-year BTC accumulation
  const yearlyBtc = [];
  for (let yr = 1; yr <= 5; yr++) {
    const endMonth = Math.min(yr * 12, out.rows.length);
    const btc = out.rows.slice(0, endMonth).reduce((a, r) => a + (Number(r.NetBTC) || 0), 0);
    const price = endMonth <= out.prices.length ? out.prices[endMonth - 1] : out.prices[out.prices.length - 1];
    yearlyBtc.push({ yr, btc, value: btc * price });
  }

  return `<!doctype html>
<html><head><meta charset="utf-8">
<title>Pantheon Mining - Investment Snapshot</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<style>
  :root {
    --bg-dark: #0B1C2D;
    --bg-card: #162638;
    --gold: #D4A85A;
    --gold-light: #E8C88B;
    --text: #F5F7FA;
    --muted: #8A95A3;
    --success: #10B981;
    --border: rgba(212,168,90,.2);
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: 'Inter', system-ui, -apple-system, sans-serif;
    background: linear-gradient(135deg, #0B1C2D 0%, #0F2438 50%, #0B1C2D 100%);
    color: var(--text);
    min-height: 100vh;
    padding: 32px;
  }
  .container {
    max-width: 900px;
    margin: 0 auto;
  }

  /* Header */
  .header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    padding-bottom: 24px;
    border-bottom: 1px solid var(--border);
    margin-bottom: 28px;
  }
  .logo {
    display: flex;
    align-items: center;
    gap: 12px;
  }
  .logo-icon {
    width: 48px;
    height: 48px;
    background: linear-gradient(135deg, var(--gold), var(--gold-light));
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    font-weight: 800;
    color: var(--bg-dark);
  }
  .logo-text {
    font-size: 22px;
    font-weight: 700;
    letter-spacing: -0.5px;
  }
  .logo-sub {
    font-size: 12px;
    color: var(--gold);
    font-weight: 500;
    margin-top: 2px;
  }
  .header-right {
    text-align: right;
  }
  .header-right .project {
    font-size: 14px;
    font-weight: 600;
    color: var(--text);
  }
  .header-right .details {
    font-size: 12px;
    color: var(--muted);
    margin-top: 4px;
  }
  .header-right .timestamp {
    font-size: 11px;
    color: var(--muted);
    margin-top: 6px;
    opacity: 0.7;
  }

  /* Grade Badge */
  .grade-badge {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 6px 14px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 20px;
  }

  /* Hero Section */
  .hero {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 16px;
    margin-bottom: 28px;
  }
  .hero-card {
    background: linear-gradient(135deg, rgba(22,38,56,.9), rgba(15,30,43,.8));
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 24px;
    text-align: center;
    position: relative;
    overflow: hidden;
  }
  .hero-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: linear-gradient(90deg, transparent, var(--gold), transparent);
  }
  .hero-card.highlight {
    border-color: rgba(212,168,90,.4);
    background: linear-gradient(135deg, rgba(212,168,90,.1), rgba(15,30,43,.8));
  }
  .hero-label {
    font-size: 11px;
    font-weight: 600;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 10px;
  }
  .hero-value {
    font-size: 42px;
    font-weight: 800;
    line-height: 1;
    margin-bottom: 8px;
    background: linear-gradient(135deg, var(--text), #B8C5D3);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .hero-card.highlight .hero-value {
    background: linear-gradient(135deg, var(--gold), var(--gold-light));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .hero-card.positive .hero-value {
    background: linear-gradient(135deg, #34D399, #10B981);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .hero-sub {
    font-size: 12px;
    color: var(--muted);
  }

  /* Section */
  .section {
    margin-bottom: 24px;
  }
  .section-title {
    font-size: 13px;
    font-weight: 700;
    color: var(--gold);
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 14px;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .section-title::after {
    content: '';
    flex: 1;
    height: 1px;
    background: linear-gradient(90deg, var(--border), transparent);
  }

  /* Comparison Cards */
  .comparison {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    gap: 16px;
    align-items: stretch;
    margin-bottom: 24px;
  }
  .compare-card {
    background: rgba(22,38,56,.6);
    border: 1px solid rgba(35,48,71,.8);
    border-radius: 14px;
    padding: 20px;
    text-align: center;
  }
  .compare-card.winner {
    border-color: rgba(16,185,129,.4);
    background: linear-gradient(135deg, rgba(16,185,129,.1), rgba(22,38,56,.6));
  }
  .compare-method {
    font-size: 12px;
    font-weight: 600;
    color: var(--muted);
    margin-bottom: 10px;
  }
  .compare-btc {
    font-size: 28px;
    font-weight: 700;
    margin-bottom: 4px;
  }
  .compare-card.winner .compare-btc {
    color: var(--success);
  }
  .compare-label {
    font-size: 11px;
    color: var(--muted);
  }
  .compare-vs {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    font-weight: 700;
    color: var(--muted);
  }

  /* Advantage Banner */
  .advantage-banner {
    background: linear-gradient(90deg, rgba(16,185,129,.15), transparent);
    border-left: 3px solid var(--success);
    padding: 14px 18px;
    border-radius: 0 12px 12px 0;
    margin-bottom: 24px;
  }
  .advantage-banner.negative {
    background: linear-gradient(90deg, rgba(239,68,68,.15), transparent);
    border-left-color: #EF4444;
  }
  .advantage-label {
    font-size: 10px;
    font-weight: 600;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .advantage-value {
    font-size: 20px;
    font-weight: 700;
    color: var(--success);
    margin-top: 4px;
  }
  .advantage-banner.negative .advantage-value {
    color: #EF4444;
  }

  /* Stats Grid */
  .stats-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 12px;
    margin-bottom: 24px;
  }
  .stat-card {
    background: rgba(22,38,56,.5);
    border: 1px solid rgba(35,48,71,.6);
    border-radius: 12px;
    padding: 14px;
  }
  .stat-label {
    font-size: 10px;
    font-weight: 600;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.3px;
    margin-bottom: 6px;
  }
  .stat-value {
    font-size: 16px;
    font-weight: 700;
  }

  /* Timeline */
  .timeline {
    display: flex;
    gap: 8px;
    margin-bottom: 24px;
  }
  .timeline-year {
    flex: 1;
    background: rgba(22,38,56,.5);
    border: 1px solid rgba(35,48,71,.6);
    border-radius: 10px;
    padding: 12px 8px;
    text-align: center;
  }
  .timeline-yr {
    font-size: 10px;
    font-weight: 600;
    color: var(--gold);
    margin-bottom: 6px;
  }
  .timeline-btc {
    font-size: 14px;
    font-weight: 700;
    margin-bottom: 2px;
  }
  .timeline-val {
    font-size: 10px;
    color: var(--muted);
  }

  /* Chart */
  .chart-container {
    background: rgba(15,23,42,.4);
    border: 1px solid rgba(35,48,71,.6);
    border-radius: 14px;
    padding: 16px;
    margin-bottom: 24px;
  }
  .chart-container img {
    width: 100%;
    border-radius: 10px;
  }

  /* Key Drivers Table */
  .drivers-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 12px;
    margin-bottom: 24px;
  }
  .drivers-table td {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(35,48,71,.4);
  }
  .drivers-table td:first-child {
    color: var(--muted);
    width: 60%;
  }
  .drivers-table td:last-child {
    text-align: right;
    font-weight: 600;
  }

  /* Footer */
  .footer {
    margin-top: 32px;
    padding-top: 20px;
    border-top: 1px solid var(--border);
  }
  .footer-risks {
    font-size: 11px;
    color: var(--muted);
    line-height: 1.6;
    margin-bottom: 16px;
  }
  .footer-disclaimer {
    font-size: 10px;
    color: var(--muted);
    opacity: 0.6;
    text-align: center;
  }

  /* Print Styles */
  @media print {
    body {
      background: white;
      color: #1a1a2e;
      padding: 20px;
    }
    .hero-card, .stat-card, .compare-card, .timeline-year, .chart-container {
      background: #f8f9fa;
      border-color: #e5e7eb;
    }
    .hero-value, .hero-card.highlight .hero-value, .hero-card.positive .hero-value {
      background: none;
      -webkit-text-fill-color: #1a1a2e;
      color: #1a1a2e;
    }
    .section-title { color: #D4A85A; }
    .hero-label, .stat-label, .compare-method, .compare-label, .hero-sub { color: #6b7280; }
    .advantage-banner { background: #f0fdf4; }
    .advantage-banner.negative { background: #fef2f2; }
  }
</style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <div class="logo">
        <div class="logo-icon">P</div>
        <div>
          <div class="logo-text">Pantheon Mining</div>
          <div class="logo-sub">Investment Snapshot</div>
        </div>
      </div>
      <div class="header-right">
        <div class="project">${state.project || 'Mining Operation'}</div>
        <div class="details">${state.minerCount.toLocaleString()} miners ¬∑ ${state.holdMonths} month hold</div>
        <div class="timestamp">Generated ${ts} at ${timeStr}</div>
      </div>
    </div>

    <!-- Grade Badge -->
    <div class="grade-badge" style="background:${gradeColor}22; color:${gradeColor}; border:1px solid ${gradeColor}44">
      <span>‚óè</span> Investment Grade: ${grade}
    </div>

    <!-- Hero Metrics -->
    <div class="hero">
      <div class="hero-card highlight">
        <div class="hero-label">Return Multiple</div>
        <div class="hero-value">${moicStr}</div>
        <div class="hero-sub">MOIC (BTC value only)</div>
      </div>
      <div class="hero-card${irrVal !== null && irrVal >= 0.15 ? ' positive' : ''}">
        <div class="hero-label">Annualized Return</div>
        <div class="hero-value">${irrStr}</div>
        <div class="hero-sub">IRR (pre-tax)</div>
      </div>
      <div class="hero-card${paybackMonths !== '‚Äî' && parseInt(paybackMonths) <= 30 ? ' positive' : ''}">
        <div class="hero-label">Capital Recovery</div>
        <div class="hero-value">${paybackMonths}</div>
        <div class="hero-sub">months to payback</div>
      </div>
    </div>

    <!-- Mining vs Buying -->
    <div class="section-title">Mining vs. Buying Comparison</div>
    <div class="comparison">
      <div class="compare-card${out.endingBTC > dcaBTC ? ' winner' : ''}">
        <div class="compare-method">‚õèÔ∏è Mining</div>
        <div class="compare-btc">${fmtNum(out.endingBTC, 4)}</div>
        <div class="compare-label">BTC acquired</div>
      </div>
      <div class="compare-vs">VS</div>
      <div class="compare-card${dcaBTC > out.endingBTC ? ' winner' : ''}">
        <div class="compare-method">üíµ DCA Buying</div>
        <div class="compare-btc">${fmtNum(dcaBTC, 4)}</div>
        <div class="compare-label">BTC acquired</div>
      </div>
    </div>

    <!-- Advantage Banner -->
    <div class="advantage-banner${miningAdvantage < 0 ? ' negative' : ''}">
      <div class="advantage-label">Mining ${miningAdvantage >= 0 ? 'Advantage' : 'Disadvantage'}</div>
      <div class="advantage-value">${miningAdvantage >= 0 ? '+' : ''}${fmtNum(miningAdvantage, 4)} BTC (${advPct >= 0 ? '+' : ''}${fmtNum(advPct, 1)}%)</div>
    </div>

    <!-- Key Stats -->
    <div class="section-title">Investment Summary</div>
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-label">Total Capex</div>
        <div class="stat-value">${sym}${fmtMoney(toDisplay(out.capex), state.currency)}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Cost per BTC</div>
        <div class="stat-value">${sym}${fmtMoney(toDisplay(costPerBtc), state.currency)}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Ending BTC</div>
        <div class="stat-value">${fmtNum(out.endingBTC, 4)}</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Ending Value</div>
        <div class="stat-value">${sym}${fmtMoney(toDisplay(out.endingValueUSD), state.currency)}</div>
      </div>
    </div>

    <!-- 5-Year Timeline -->
    <div class="section-title">5-Year BTC Accumulation</div>
    <div class="timeline">
      ${yearlyBtc.map(y => `
        <div class="timeline-year">
          <div class="timeline-yr">Year ${y.yr}</div>
          <div class="timeline-btc">${fmtNum(y.btc, 3)}</div>
          <div class="timeline-val">${sym}${fmtMoney(toDisplay(y.value), state.currency)}</div>
        </div>
      `).join('')}
    </div>

    <!-- Chart -->
    ${chartImg ? `
    <div class="section-title">Net Value Projection</div>
    <div class="chart-container">
      <img src="${chartImg}" alt="Net Value Chart">
    </div>
    ` : ''}

    <!-- Key Drivers -->
    <div class="section-title">Model Assumptions</div>
    <table class="drivers-table">
      <tbody>
        <tr><td>Starting BTC Price</td><td>${sym}${Math.round(toDisplay(getBtcPriceUSD())).toLocaleString()}</td></tr>
        <tr><td>Price Model</td><td>${priceModelDesc}</td></tr>
        <tr><td>Power Cost</td><td>${sym}${state.powerCost.toFixed(3)} / kWh</td></tr>
        <tr><td>Difficulty Growth (annual)</td><td>${fmtNum(state.difficultyGrowth, 1)}%</td></tr>
        <tr><td>Uptime</td><td>${fmtNum(state.uptime, 1)}%</td></tr>
        <tr><td>All-in Fees</td><td>${fmtNum(state.poolFee + state.hostingFee + state.managementFee + state.insuranceFee + state.repairReserve, 2)}%</td></tr>
      </tbody>
    </table>

    <!-- Footer -->
    <div class="footer">
      <div class="footer-risks">
        <strong style="color:var(--gold)">Risk Factors:</strong> Bitcoin price volatility ¬∑ Network difficulty changes ¬∑ Downtime and hardware failure ¬∑ Hosting/power counterparty risk ¬∑ Regulatory and tax uncertainty
      </div>
      <div class="footer-disclaimer">
        This is a simplified, pre-tax model for illustrative purposes only. Past performance does not guarantee future results. All projections are scenario-based estimates and should not be construed as investment advice. ¬© ${new Date().getFullYear()} Pantheon Mining
      </div>
    </div>
  </div>
</body></html>`;
}

function exportOnePager(){
  const html = buildOnePagerHtml();
  const blob = new Blob([html], {type:"text/html"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "pantheon-investment-snapshot.html";
  document.body.appendChild(a);
  try{
    a.click();
  }catch{
    window.open(url, "_blank");
  }
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 2000);
}

function exportPdfOnePager(){
  const html = buildOnePagerHtml();
  const iframe = document.createElement("iframe");
  iframe.style.position = "fixed";
  iframe.style.right = "0";
  iframe.style.bottom = "0";
  iframe.style.width = "0";
  iframe.style.height = "0";
  iframe.style.border = "0";
  document.body.appendChild(iframe);

  const doc = iframe.contentWindow.document;
  doc.open();
  doc.write(html);
  doc.close();

  iframe.onload = () => {
    try{
      iframe.contentWindow.focus();
      iframe.contentWindow.print();
    }finally{
      setTimeout(()=>iframe.remove(), 1000);
    }
  };
}

// ---------- Core model ----------
function getInputs(){
  // pull from DOM
  state.minerModel = UI.minerModel.value;
  state.currency = UI.currency.value;
  state.fxRate = Number(UI.fxRate.value);
  state.minerCount = clamp(parseInt(UI.minerCount.value || 1, 10), 1, 1000000);
  state.holdMonths = clamp(parseInt(UI.holdMonths.value || 1, 10), 1, 120);
  state.btcOverride = UI.btcOverride.value;

  // Cycle model parameters
  state.priceDrift = Number(UI.priceDrift.value);
  state.priceCycleAmp = Number(UI.priceCycleAmp.value);
  state.priceCycleMonths = Number(UI.priceCycleMonths.value);
  state.halvingAnchor = UI.halvingAnchor.value || DEFAULTS.halvingAnchor;

  // Custom price model parameters
  if (UI.priceY1) state.priceY1 = clamp(Number(UI.priceY1.value) || 0, -90, 500);
  if (UI.priceY2) state.priceY2 = clamp(Number(UI.priceY2.value) || 0, -90, 500);
  if (UI.priceY3) state.priceY3 = clamp(Number(UI.priceY3.value) || 0, -90, 500);
  if (UI.priceY4) state.priceY4 = clamp(Number(UI.priceY4.value) || 0, -90, 500);
  if (UI.priceY5) state.priceY5 = clamp(Number(UI.priceY5.value) || 0, -90, 500);

  state.unitCapex = Number(UI.unitCapex.value);
  state.powerCost = Number(UI.powerCost.value);
  state.hashratePerMiner = Number(UI.hashratePerMiner.value);
  state.powerPerMiner = Number(UI.powerPerMiner.value);
  state.networkHashrateEH = Number(UI.networkHashrateEH.value);
  state.uptime = Number(UI.uptime.value);
  state.poolFee = Number(UI.poolFee.value);
  state.hostingFee = Number(UI.hostingFee.value);
  state.managementFee = Number(UI.managementFee.value);
  state.insuranceFee = Number(UI.insuranceFee.value);
  state.repairReserve = Number(UI.repairReserve.value);state.degradation = Number(UI.degradation.value);
  state.difficultyGrowth = Number(UI.difficultyGrowth.value);
  state.resaleValue = Number(UI.resaleValue.value);
  state.reinvestBtc = UI.reinvestBtc.checked;

  state.investorMode = UI.investorMode ? UI.investorMode.checked : !!state.investorMode;

  // sanitize
  for(const k of Object.keys(DEFAULTS)){
    if(typeof DEFAULTS[k] === "number") state[k] = Number.isFinite(state[k]) ? state[k] : DEFAULTS[k];
  }
}

function getBtcPriceUSD(){
  // priority: manual override > fetched spot > fallback constant
  const manual = Number(UI.btcOverride.value);
  if(Number.isFinite(manual) && manual > 0) return manual;
  if(Number.isFinite(btcSpotUSD) && btcSpotUSD > 0) return btcSpotUSD;
  return 100000; // fallback so UI isn't empty
}

function monthsSinceHalving(anchor){
  const anchorDate = new Date(anchor + "T00:00:00Z");
  if(Number.isNaN(anchorDate.getTime())) return 0;
  const now = new Date();
  const months = (now.getUTCFullYear() - anchorDate.getUTCFullYear()) * 12 + (now.getUTCMonth() - anchorDate.getUTCMonth());
  return Math.max(0, months);
}

function cycleFactor(monthIndex){
  const cycleMonths = clamp(Number(state.priceCycleMonths) || 48, 12, 120);
  const amp = clamp(Number(state.priceCycleAmp) || 0, 0, 200) / 100;
  const t0 = monthsSinceHalving(state.halvingAnchor || DEFAULTS.halvingAnchor);
  const t = t0 + monthIndex;
  const phase = (2 * Math.PI * (t / cycleMonths)) - Math.PI / 2;
  const raw = 1 + amp * Math.sin(phase);
  return Math.max(0.2, raw);
}

/**
 * Generates a price path array for the specified number of months.
 * Supports two modes:
 * - "cycle": Uses drift + amplitude sine wave cycle model
 * - "custom": Uses explicit year-by-year percentage changes
 *
 * @param {number} months - Number of months to project
 * @returns {number[]} Array of projected BTC prices (USD)
 */
function pricePathUSD(months){
  const p0 = getBtcPriceUSD();

  // Custom Annual Mode: Apply year-specific growth rates
  if (state.priceModel === "custom") {
    return pricePathCustomAnnual(p0, months);
  }

  // Cycle Model: Use drift + amplitude (original behavior)
  const drift = clamp(Number(state.priceDrift) || 0, -90, 200) / 100;
  const prices = [];
  const c0 = cycleFactor(0);
  for(let i=0; i<months; i++){
    const trend = Math.pow(1 + drift, i/12);
    const c = cycleFactor(i);
    const price = p0 * trend * (c / c0);
    prices.push(Math.max(100, price)); // Floor at $100 to prevent division issues
  }
  return prices;
}

/**
 * Custom Annual price path - applies year-specific growth rates.
 * Within each year, price grows linearly toward the year-end target.
 *
 * @param {number} startPrice - Starting BTC price (USD)
 * @param {number} months - Number of months to project
 * @returns {number[]} Array of projected BTC prices (USD)
 */
function pricePathCustomAnnual(startPrice, months) {
  const yearGrowth = [
    clamp(Number(state.priceY1) || 0, -90, 500) / 100,
    clamp(Number(state.priceY2) || 0, -90, 500) / 100,
    clamp(Number(state.priceY3) || 0, -90, 500) / 100,
    clamp(Number(state.priceY4) || 0, -90, 500) / 100,
    clamp(Number(state.priceY5) || 0, -90, 500) / 100,
  ];

  const prices = [];
  let yearStartPrice = startPrice;

  for (let m = 0; m < months; m++) {
    const yearIndex = Math.floor(m / 12);
    const monthInYear = m % 12;

    // Clamp to last year's growth rate if beyond year 5
    const growth = yearGrowth[Math.min(yearIndex, 4)];
    const yearEndPrice = yearStartPrice * (1 + growth);

    // Linear interpolation within the year
    const progress = (monthInYear + 1) / 12;
    const price = yearStartPrice + (yearEndPrice - yearStartPrice) * progress;

    // Floor at $100 to prevent division issues, but allow very low prices
    prices.push(Math.max(100, price));

    // At year boundary, update yearStartPrice
    if (monthInYear === 11) {
      yearStartPrice = yearEndPrice;
    }
  }

  return prices;
}

/**
 * Gets projected prices at year-end boundaries for display purposes.
 * @returns {number[]} Array of 6 prices: [start, y1, y2, y3, y4, y5]
 */
function getYearEndPrices() {
  const p0 = getBtcPriceUSD();
  const yearGrowth = [
    clamp(Number(state.priceY1) || 0, -90, 500) / 100,
    clamp(Number(state.priceY2) || 0, -90, 500) / 100,
    clamp(Number(state.priceY3) || 0, -90, 500) / 100,
    clamp(Number(state.priceY4) || 0, -90, 500) / 100,
    clamp(Number(state.priceY5) || 0, -90, 500) / 100,
  ];

  const prices = [p0];
  let price = p0;
  for (let i = 0; i < 5; i++) {
    price = price * (1 + yearGrowth[i]);
    prices.push(Math.max(100, price));
  }
  return prices;
}

function effectiveRunFrac(){
  const uptime = clamp(state.uptime/100, 0, 1);
  return uptime;
}


function monthlyHashrateTH(monthIndex){
  // degradation applies to miner hashrate (simple linear-ish exponential)
  const degradeMonthly = Math.pow(1 - clamp(state.degradation,0,99)/100, 1/12);
  return state.hashratePerMiner * Math.pow(degradeMonthly, monthIndex);
}

function monthlyNetworkHashEH(monthIndex){  const g = Math.pow(1 + state.difficultyGrowth/100, 1/12);
  return state.networkHashrateEH * Math.pow(g, monthIndex);
}

function blockRewardBTC(monthIndex){
  // halving in month 28 => monthIndex 27 is month 28 in 1-based
  return monthIndex >= 27 ? 1.5625 : 3.125;
}

/**
 * Core economic model for Bitcoin mining profitability.
 *
 * Computes month-by-month projections including:
 * - BTC production (accounting for difficulty growth, degradation, halvings)
 * - Revenue and OPEX (power, hosting, management, insurance, repairs)
 * - IRR and MOIC calculations
 * - Cumulative cash flow and net value curves
 *
 * @returns {Object} Model output with rows[], prices[], capex, resale, endingBTC,
 *                   endingValueUSD, moic, moicNoResale, irrA, irrANoResale,
 *                   cumulativeRevenue, cumulativeCosts, cumulativeNet
 */
function model(){
  const months = state.holdMonths;
  const daysPerMonth = 30.4375;
  const blocksPerDay = 144;

  const prices = pricePathUSD(months);

  const capex = state.minerCount * state.unitCapex;
  const resale = capex * (clamp(state.resaleValue,0,100)/100);

  const runFrac = effectiveRunFrac();
  const poolFrac = clamp(state.poolFee/100,0,1);
  const hostFrac = clamp(state.hostingFee/100,0,1);
  const mgmtFrac = clamp(state.managementFee/100,0,1);
  const insFrac  = clamp(state.insuranceFee/100,0,1);
  const repairFrac = clamp(state.repairReserve/100,0,1);

  const rows = [];
  let cumCash = 0;        // cumulative out-of-pocket OPEX (positive)
  let btcHeld = 0;        // BTC held over time (after any sales for OPEX)
  let endingBTC = 0;
  let cashflows = [-capex]; // cash-only IRR inputs

  for(let m=0; m<months; m++){
    const minerHashTH = monthlyHashrateTH(m) * state.minerCount;
    const netHashTH = monthlyNetworkHashEH(m) * 1_000_000; // EH -> TH

    const share = netHashTH > 0 ? minerHashTH / netHashTH : 0;

    const grossBTC = share * blocksPerDay * daysPerMonth * blockRewardBTC(m) * runFrac;

    const poolBTC = grossBTC * poolFrac;
    const netBTC = Math.max(0, grossBTC - poolBTC);

    const price = prices[m];
    const revenue = netBTC * price;

    const powerUSD = state.minerCount * state.powerPerMiner * 24 * daysPerMonth * state.powerCost * runFrac;
    const hostingUSD = revenue * hostFrac;
    const mgmtUSD = revenue * mgmtFrac;
    const insUSD = revenue * insFrac;
    const repairsUSD = capex * repairFrac / 12;

    const opex = powerUSD + hostingUSD + mgmtUSD + insUSD + repairsUSD;

    // If reinvest: sell BTC to cover OPEX up to available netBTC
    let btcSoldForOpex = 0;
    let outOfPocket = 0;

    if(state.reinvestBtc){
      btcSoldForOpex = Math.min(netBTC, opex / price);
      outOfPocket = Math.max(0, opex - btcSoldForOpex * price);
      btcHeld += (netBTC - btcSoldForOpex);
    }else{
      outOfPocket = opex; // all opex paid in cash
      btcHeld += netBTC;
    }

    // Cash-only monthly flow (negative = money out)
    const netCash = -outOfPocket;
    cashflows.push(netCash);

    // Track cumulative cash paid (positive) and "net value" including marked-to-market BTC held
    cumCash += outOfPocket;
    const netValueUSD = (-capex - cumCash) + (btcHeld * price); // resale handled at the end

    rows.push({
      Month: m+1,
      GrossBTC: grossBTC,
      PoolFeeBTC: poolBTC,
      NetBTC: netBTC,
      BTCHeld: btcHeld,
      BTCPrice: price,
      RevenueUSD: revenue,
      PowerUSD: powerUSD,
      HostingUSD: hostingUSD,
      MgmtUSD: mgmtUSD,
      InsuranceUSD: insUSD,
      RepairsUSD: repairsUSD,
      NetCashUSD: netCash,
      NetValueUSD: netValueUSD,
      // Cash-only cumulative (still useful to see how much you've paid out of pocket)
      CumulativeCashOutUSD: (-capex - cumCash),
    });
  }

  // End state
  endingBTC = btcHeld;
  const endPrice = prices[prices.length-1];
  const endingValueUSD = endingBTC * endPrice;

  // Total invested cash = capex + sum(out-of-pocket) = -sum(cashflows)
  const totalCashInvested = -cashflows.reduce((a,b)=>a+b,0);

  const moic = totalCashInvested > 0 ? (endingValueUSD + resale) / totalCashInvested : 0;

  // Conservative headline metrics (exclude ASIC resale / liquidation unless explicitly shown)
  const moicNoResale = totalCashInvested > 0 ? (endingValueUSD) / totalCashInvested : 0;


  // IRR (net): include terminal liquidation value of BTC held + resale at end of hold period.
  // Even if BTC is held during the period, IRR is solved by realizing value at exit.
  const terminalValue = endingValueUSD + resale;
  const cashflowsNet = cashflows.slice();
  cashflowsNet[cashflowsNet.length - 1] = cashflowsNet[cashflowsNet.length - 1] + terminalValue;

  // IRR excluding resale (BTC value only)
  const cashflowsNetNoResale = cashflows.slice();
  cashflowsNetNoResale[cashflowsNetNoResale.length - 1] = cashflowsNetNoResale[cashflowsNetNoResale.length - 1] + endingValueUSD;

  cashflowsNet[cashflowsNet.length - 1] = cashflowsNet[cashflowsNet.length - 1] + terminalValue;
  const irrM = irrMonthly(cashflowsNet);
  const irrA = irrM === null ? null : (Math.pow(1+irrM, 12) - 1);
  const irrMNoResale = irrMonthly(cashflowsNetNoResale);
  const irrANoResale = irrMNoResale === null ? null : (Math.pow(1+irrMNoResale, 12) - 1);

  // For tiles: "revenue" is theoretical revenue from mined BTC (even if held)
  const cumulativeRevenue = rows.reduce((a,r)=>a + r.RevenueUSD, 0);
  const cumulativeOpex = rows.reduce((a,r)=>a + (r.PowerUSD+r.HostingUSD+r.MgmtUSD+r.InsuranceUSD+r.RepairsUSD), 0);
  const cumulativeCosts = capex + cumulativeOpex;
  const cumulativeNet = cumulativeRevenue - cumulativeCosts + resale;

  return {
    rows, prices,
    capex, resale,
    endingBTC, endingValueUSD,
    totalCashInvested,
    moic,
    moicNoResale,
    irrA,
    irrANoResale,
    cumulativeRevenue, cumulativeCosts, cumulativeNet,
    totalOpex: cumulativeOpex,
  };
}

// ---------- Rendering ----------
let profitabilityChart = null;
let execNetValueChart = null;

function render(modelOut){
  const sym = symbolFor(state.currency);
  UI.currencySymbol.textContent = sym;
  document.getElementById("currencySymbol1").textContent = sym;
  document.getElementById("currencySymbol2").textContent = sym;
  document.getElementById("currencySymbol3").textContent = sym;
  document.getElementById("currencySymbol5").textContent = sym;
  document.getElementById("currencySymbol6").textContent = sym;

  UI.totalCapex.textContent = fmtMoney(toDisplay(modelOut.capex), state.currency);

  UI.revenue.textContent = fmtMoney(toDisplay(modelOut.cumulativeRevenue), state.currency);
  UI.costs.textContent = fmtMoney(toDisplay(modelOut.cumulativeCosts), state.currency);
  UI.netCash.textContent = fmtMoney(toDisplay(modelOut.cumulativeNet), state.currency);

  UI.btcMined.textContent = fmtNum(modelOut.endingBTC, 4);
  UI.miningBtc.textContent = fmtNum(modelOut.endingBTC, 4);
  UI.miningValue.textContent = fmtMoney(toDisplay(modelOut.endingValueUSD + modelOut.resale), state.currency);

  // DCA: match actual cash outflows by month (capex upfront + monthly out-of-pocket OPEX)
  const months = state.holdMonths;
  let dcaBTC = 0;
  if(modelOut.prices.length){
    dcaBTC += modelOut.capex / modelOut.prices[0];
  }
  for(let i=0; i<modelOut.rows.length; i++){
    const outOfPocket = Math.max(0, -Number(modelOut.rows[i].NetCashUSD || 0));
    if(outOfPocket > 0){
      dcaBTC += outOfPocket / modelOut.prices[i];
    }
  }
  const dcaValue = dcaBTC * modelOut.prices[months-1];

  UI.dcaBtc.textContent = fmtNum(dcaBTC, 4);
  UI.dcaValue.textContent = fmtMoney(toDisplay(dcaValue), state.currency);

  // IRR & MOIC
  UI.moic.textContent = fmtNum(modelOut.moic, 2);
  UI.irr.textContent = modelOut.irrA === null ? "‚Äî" : fmtNum(modelOut.irrA*100, 1);

    
  // --- Enhanced Executive View ---
  updateExecutiveView(modelOut, sym, dcaBTC, dcaValue);

  // Executive Chart: Cumulative Net Value with gradient fill
  const execCanvas = document.getElementById("execNetValueChart");
  if(execCanvas && window.Chart){
    const labelsExec = modelOut.rows.map(r => r.Month);
    const netValueSeries = modelOut.rows.map(r => toDisplay(r.NetValueUSD));
    const finalValue = netValueSeries[netValueSeries.length - 1] || 0;
    const isPositive = finalValue >= 0;

    // Create gradient
    const ctx = execCanvas.getContext('2d');
    const gradient = ctx.createLinearGradient(0, 0, 0, 260);
    if (isPositive) {
      gradient.addColorStop(0, 'rgba(52, 211, 153, 0.3)');
      gradient.addColorStop(1, 'rgba(52, 211, 153, 0)');
    } else {
      gradient.addColorStop(0, 'rgba(248, 113, 113, 0.3)');
      gradient.addColorStop(1, 'rgba(248, 113, 113, 0)');
    }

    const lineColor = isPositive ? '#34D399' : '#F87171';

    if(!execNetValueChart){
      execNetValueChart = new Chart(execCanvas, {
        type:"line",
        data:{
          labels: labelsExec,
          datasets:[{
            label:"Cumulative Net Value",
            data: netValueSeries,
            borderWidth:2,
            borderColor: lineColor,
            backgroundColor: gradient,
            fill: true,
            pointRadius:0,
            pointHoverRadius:4,
            pointHoverBackgroundColor: lineColor,
            tension:.3
          }]
        },
        options:{
          responsive:true,
          maintainAspectRatio:false,
          interaction:{mode:"index", intersect:false},
          plugins:{
            legend:{display:false},
            tooltip:{
              backgroundColor:'rgba(11,28,45,.95)',
              borderColor:'rgba(35,48,71,.8)',
              borderWidth:1,
              titleColor:'#9ca3af',
              bodyColor:'#f5f7fa',
              padding:10,
              cornerRadius:8,
              callbacks:{
                label:(ctx)=> `Net Value: ${sym}${Math.round(Number(ctx.raw||0)).toLocaleString()}`
              }
            }
          },
          scales:{
            x:{ticks:{color:"#6b7280", maxTicksLimit:12}, grid:{color:"rgba(35,48,71,.25)"}},
            y:{ticks:{color:"#6b7280", callback:(v)=>`${sym}${Number(v).toLocaleString()}`}, grid:{color:"rgba(35,48,71,.25)"}}
          }
        }
      });
    }else{
      // Update gradient based on current values
      const newGradient = ctx.createLinearGradient(0, 0, 0, 260);
      if (isPositive) {
        newGradient.addColorStop(0, 'rgba(52, 211, 153, 0.3)');
        newGradient.addColorStop(1, 'rgba(52, 211, 153, 0)');
      } else {
        newGradient.addColorStop(0, 'rgba(248, 113, 113, 0.3)');
        newGradient.addColorStop(1, 'rgba(248, 113, 113, 0)');
      }
      execNetValueChart.data.labels = labelsExec;
      execNetValueChart.data.datasets[0].data = netValueSeries;
      execNetValueChart.data.datasets[0].borderColor = lineColor;
      execNetValueChart.data.datasets[0].backgroundColor = newGradient;
      execNetValueChart.data.datasets[0].pointHoverBackgroundColor = lineColor;
      execNetValueChart.update();
    }
  }
// Chart: match screenshot-style profitability chart
  // Bars: Revenue, Profit (operating), Electricity Cost
  // Lines (right axis): Cash Flow (Cumulative, cash basis) and Profit/Loss (Cumulative, net value)
  const labels = modelOut.rows.map(r => r.Month);

  const revenue = modelOut.rows.map(r => toDisplay(r.RevenueUSD));
  const electricity = modelOut.rows.map(r => toDisplay(r.PowerUSD));
  const totalOpex = modelOut.rows.map(r => toDisplay(r.PowerUSD + r.HostingUSD + r.MgmtUSD + r.InsuranceUSD + r.RepairsUSD));
  const profit = modelOut.rows.map((r, i) => (revenue[i] - totalOpex[i])); // operating profit before capex

  // Net Cash (cumulative): -capex - out-of-pocket OPEX (cash only)
  let runCash = -toDisplay(modelOut.capex);
  const cashFlowCum = modelOut.rows.map(r => (runCash += toDisplay(r.NetCashUSD)));
// Profit/Loss (cumulative): net value curve (already includes BTC mark-to-market)
  const profitLossCum = modelOut.rows.map(r => toDisplay(r.NetValueUSD));

  const ctx = document.getElementById("profitabilityChart");

  if(typeof Chart !== "undefined"){
  if(!profitabilityChart){
    profitabilityChart = new Chart(ctx, {
      data:{
        labels,
        datasets:[
          { type:"bar", label:"Revenue", data: revenue, borderWidth:0, yAxisID:"y" },
          { type:"bar", label:"Profit", data: profit, borderWidth:0, yAxisID:"y" },
          { type:"bar", label:"Electricity Cost", data: electricity, borderWidth:0, yAxisID:"y" },

          { type:"line", label:"Net Cash (Cumulative)", data: cashFlowCum, borderWidth:2, pointRadius:0, tension:.25, yAxisID:"y1" },
          { type:"line", label:"Profit/Loss (Cumulative)", data: profitLossCum, borderWidth:2, pointRadius:0, tension:.25, yAxisID:"y1" },
        ]
      },
      options:{
        responsive:true,
        maintainAspectRatio:false,
        interaction:{mode:"index", intersect:false},
        plugins:{
          legend:{display:true, labels:{color:"#e5e7eb"}},
          tooltip:{callbacks:{
            label: (ctx) => {
              const v = Number(ctx.raw || 0);
              const isBTC = false;
              const prefix = (ctx.dataset.type === "line" || ctx.dataset.type === "bar") ? sym : "";
              return `${ctx.dataset.label}: ${prefix}${Math.round(v).toLocaleString()}`;
            }
          }}
        },
        scales:{
          x:{ticks:{color:"#9ca3af"}, grid:{color:"rgba(35,48,71,.35)"}},
          y:{
            position:"left",
            ticks:{color:"#9ca3af", callback:(v)=>`${sym}${Number(v).toLocaleString()}`},
            grid:{color:"rgba(35,48,71,.35)"},
            title:{display:true, text:"Revenue & Profit", color:"#9ca3af"}
          },
          y1:{
            position:"right",
            ticks:{color:"#9ca3af", callback:(v)=>`${sym}${Number(v).toLocaleString()}`},
            grid:{drawOnChartArea:false},
            title:{display:true, text:"Net Cash & Profit/Loss (Cumulative)", color:"#9ca3af"}
          }
        }
      }
    });
  }else{
    profitabilityChart.data.labels = labels;
    profitabilityChart.data.datasets[0].data = revenue;
    profitabilityChart.data.datasets[1].data = profit;
    profitabilityChart.data.datasets[2].data = electricity;
    profitabilityChart.data.datasets[3].data = cashFlowCum;
    profitabilityChart.data.datasets[4].data = profitLossCum;
    profitabilityChart.update();
  }
  }else{
    // Chart.js unavailable (offline / blocked). Skip chart rendering.
  }

  // Yearly tiles
  UI.yearly.innerHTML = "";
  const years = Math.ceil(months/12);
  const canShowMined = !!UI.showBtcMined;
  const showMined = canShowMined ? !!UI.showBtcMined.checked : false; // default to BTC held
  for(let y=1; y<=years; y++){
    const startIdx = Math.max(0, (y-1)*12);
    const mIdx = Math.min(y*12-1, months-1);

    // BTC held after any sales for OPEX (best), else fallback to cumulative NetBTC.
    const btcHeld = (modelOut.rows[mIdx] && Number.isFinite(modelOut.rows[mIdx].BTCHeld))
      ? modelOut.rows[mIdx].BTCHeld
      : modelOut.rows.slice(0, mIdx+1).reduce((a,r)=>a + r.NetBTC, 0);

    const btcMined = modelOut.rows.slice(0, mIdx+1).reduce((a,r)=>a + r.NetBTC, 0);
    const btcShown = showMined ? btcMined : btcHeld;

    const priceStart = modelOut.prices[startIdx];
    const priceEnd = modelOut.prices[mIdx];
    const yoy = (Number.isFinite(priceStart) && Number.isFinite(priceEnd) && priceStart>0) ? (priceEnd/priceStart - 1) : 0;

    const valDisp = toDisplay(btcShown * priceEnd);

    const div = document.createElement("div");
    div.className="tile";
    div.innerHTML = `
      <h4>Year ${y}</h4>
      <p>${sym}${fmtMoney(valDisp, state.currency)}</p>
      <div class="muted" style="margin-top:6px">BTC Price YoY: ${(yoy*100).toFixed(1)}%</div>
      <div class="muted" style="margin-top:6px">BTC: ${fmtNum(btcShown, 4)}</div>
    `;
    UI.yearly.appendChild(div);
  }

  // Cashflow table (monthly or annual summary)
  const view = (state.cashflowView || (state.investorMode ? "annual" : "monthly"));
  if(UI.cashflowViewLabel) UI.cashflowViewLabel.textContent = `View: ${view === "annual" ? "Annual summary" : "Monthly"}`;
  if(UI.toggleCashflowView) UI.toggleCashflowView.textContent = view === "annual" ? "Switch to Monthly Detail" : "Switch to Annual Summary";

  UI.cashflowTbody.innerHTML = "";
  const frag = document.createDocumentFragment();

  if(view === "annual"){
    const years = Math.ceil(modelOut.rows.length / 12);
    for(let y=0;y<years;y++){
      const slice = modelOut.rows.slice(y*12, (y+1)*12);
      if(!slice.length) continue;
      const sum = (k)=>slice.reduce((a,r)=>a + (r[k]||0), 0);
      const avgPrice = slice.reduce((a,r)=>a + (r.BTCPrice||0), 0) / slice.length;

      const last = slice[slice.length-1];
      const tr = document.createElement("tr");
      tr.className = "year-subtotal";
      tr.innerHTML = `
        <td>Year ${y+1}</td>
        <td>${fmtNum(sum("GrossBTC"),5)}</td>
        <td>${fmtNum(sum("PoolFeeBTC"),5)}</td>
        <td>${fmtNum(sum("NetBTC"),5)}</td>
        <td>${sym}${Math.round(toDisplay(avgPrice)).toLocaleString()}</td>
        <td>${sym}${fmtMoney(toDisplay(sum("RevenueUSD")),state.currency)}</td>
        <td>${sym}${fmtMoney(toDisplay(sum("PowerUSD")),state.currency)}</td>
        <td>${sym}${fmtMoney(toDisplay(sum("HostingUSD")),state.currency)}</td>
        <td>${sym}${fmtMoney(toDisplay(sum("MgmtUSD")),state.currency)}</td>
        <td>${sym}${fmtMoney(toDisplay(sum("InsuranceUSD")),state.currency)}</td>
        <td>${sym}${fmtMoney(toDisplay(sum("RepairsUSD")),state.currency)}</td>
        <td>${sym}${fmtMoney(toDisplay(sum("NetCashUSD")),state.currency)}</td>
        <td>${sym}${fmtMoney(toDisplay(last.NetValueUSD),state.currency)}</td>
      `;
      frag.appendChild(tr);
    }
  } else {
    for(let i=0;i<modelOut.rows.length;i++){
      const r = modelOut.rows[i];
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${r.Month}</td>
        <td>${fmtNum(r.GrossBTC,5)}</td>
        <td>${fmtNum(r.PoolFeeBTC,5)}</td>
        <td>${fmtNum(r.NetBTC,5)}</td>
        <td>${sym}${Math.round(toDisplay(r.BTCPrice)).toLocaleString()}</td>
        <td>${sym}${fmtMoney(toDisplay(r.RevenueUSD),state.currency)}</td>
        <td>${sym}${fmtMoney(toDisplay(r.PowerUSD),state.currency)}</td>
        <td>${sym}${fmtMoney(toDisplay(r.HostingUSD),state.currency)}</td>
        <td>${sym}${fmtMoney(toDisplay(r.MgmtUSD),state.currency)}</td>
        <td>${sym}${fmtMoney(toDisplay(r.InsuranceUSD),state.currency)}</td>
        <td>${sym}${fmtMoney(toDisplay(r.RepairsUSD),state.currency)}</td>
        <td>${sym}${fmtMoney(toDisplay(r.NetCashUSD),state.currency)}</td>
        <td>${sym}${fmtMoney(toDisplay(r.NetValueUSD),state.currency)}</td>
      `;
      frag.appendChild(tr);

      // Year subtotal every 12 months
      if((i+1) % 12 === 0){
        const slice = modelOut.rows.slice(i-11, i+1);
        const sum = (k)=>slice.reduce((a,x)=>a + (x[k]||0), 0);
        const tr2 = document.createElement("tr");
        tr2.className = "year-subtotal";
        tr2.innerHTML = `
          <td>Year ${(i+1)/12} subtotal</td>
          <td>${fmtNum(sum("GrossBTC"),5)}</td>
          <td>${fmtNum(sum("PoolFeeBTC"),5)}</td>
          <td>${fmtNum(sum("NetBTC"),5)}</td>
          <td class="muted">‚Äî</td>
          <td>${sym}${fmtMoney(toDisplay(sum("RevenueUSD")),state.currency)}</td>
          <td>${sym}${fmtMoney(toDisplay(sum("PowerUSD")),state.currency)}</td>
          <td>${sym}${fmtMoney(toDisplay(sum("HostingUSD")),state.currency)}</td>
          <td>${sym}${fmtMoney(toDisplay(sum("MgmtUSD")),state.currency)}</td>
          <td>${sym}${fmtMoney(toDisplay(sum("InsuranceUSD")),state.currency)}</td>
          <td>${sym}${fmtMoney(toDisplay(sum("RepairsUSD")),state.currency)}</td>
          <td>${sym}${fmtMoney(toDisplay(sum("NetCashUSD")),state.currency)}</td>
          <td>${sym}${fmtMoney(toDisplay(r.NetValueUSD),state.currency)}</td>
        `;
        frag.appendChild(tr2);
      }
    }
  }
  UI.cashflowTbody.appendChild(frag);

  // Sensitivity (MOIC) - quick recalcs with two dimensions
  renderSensitivity();

  // Assumptions panel
  UI.assumptionsBtcPrice.textContent = `${symbolFor(state.currency)}${Math.round(toDisplay(getBtcPriceUSD())).toLocaleString()}`;
  const ts = new Date().toLocaleString();
  UI.timestamp.textContent = ts;
  if(UI.timestamp2) UI.timestamp2.textContent = ts;
}

/**
 * Compute model output with adjusted parameters for sensitivity analysis.
 * Preserves original state after computation.
 */
function modelWithAdjustments(adjustments) {
  const saved = _structuredClone(state);

  // Apply adjustments
  Object.assign(state, adjustments);

  const out = model();

  // Restore original state
  state = saved;

  return out;
}

/**
 * Renders comprehensive sensitivity analysis tables.
 * Table 1: BTC Price vs Difficulty Growth (MOIC matrix)
 * Table 2: Power Cost sensitivity (MOIC, OPEX, Breakeven)
 */
function renderSensitivity(){
  const sym = symbolFor(state.currency);
  const basePrice = getBtcPriceUSD();
  const baseDiff = state.difficultyGrowth;
  const basePower = state.powerCost;

  // Price scenarios (as multipliers of starting price)
  const priceScenarios = [
    { label: '-30%', mult: 0.70 },
    { label: '-15%', mult: 0.85 },
    { label: 'Base', mult: 1.00 },
    { label: '+15%', mult: 1.15 },
    { label: '+30%', mult: 1.30 },
  ];

  // Difficulty scenarios (absolute values)
  const diffScenarios = [5, 15, 25, 35];

  // Render main sensitivity table (Price vs Difficulty)
  UI.sensitivityTbody.innerHTML = "";

  for (const priceScen of priceScenarios) {
    const tr = document.createElement("tr");
    const adjustedPrice = Math.round(basePrice * priceScen.mult);

    // For custom price model, we scale all year values
    // For cycle model, we adjust the starting price
    let cells = [`<td style="text-align:left"><strong>${priceScen.label}</strong><br><span class="muted">${sym}${adjustedPrice.toLocaleString()}</span></td>`];

    for (const diff of diffScenarios) {
      const adjustments = {
        difficultyGrowth: diff,
        btcOverride: String(adjustedPrice)
      };

      // If using custom price model, scale all year projections
      if (state.priceModel === 'custom') {
        adjustments.priceY1 = Math.round(state.priceY1 * priceScen.mult);
        adjustments.priceY2 = Math.round(state.priceY2 * priceScen.mult);
        adjustments.priceY3 = Math.round(state.priceY3 * priceScen.mult);
        adjustments.priceY4 = Math.round(state.priceY4 * priceScen.mult);
        adjustments.priceY5 = Math.round(state.priceY5 * priceScen.mult);
      }

      const out = modelWithAdjustments(adjustments);
      const moic = out.moicNoResale;

      // Color coding
      let cellClass = '';
      if (moic >= 1.5) cellClass = 'style="background:rgba(52,211,153,.15);color:#34d399"';
      else if (moic >= 1.0) cellClass = 'style="background:rgba(251,191,36,.1)"';
      else cellClass = 'style="background:rgba(214,106,106,.15);color:#d66a6a"';

      // Highlight current settings
      const isCurrentDiff = Math.abs(diff - baseDiff) < 3;
      const isCurrentPrice = Math.abs(priceScen.mult - 1.0) < 0.05;
      if (isCurrentDiff && isCurrentPrice) {
        cellClass = 'style="background:rgba(96,165,250,.2);border:2px solid rgba(96,165,250,.5)"';
      }

      cells.push(`<td ${cellClass}><strong>${fmtNum(moic, 2)}x</strong></td>`);
    }

    tr.innerHTML = cells.join('');
    UI.sensitivityTbody.appendChild(tr);
  }

  // Render power cost sensitivity table
  if (UI.powerSensitivityTbody) {
    UI.powerSensitivityTbody.innerHTML = "";

    const powerScenarios = [0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.10];

    for (const power of powerScenarios) {
      const out = modelWithAdjustments({ powerCost: power });
      const moic = out.moicNoResale;

      // Calculate monthly OPEX
      const monthlyOpex = out.rows.length > 0
        ? (out.rows[0].PowerUSD + out.rows[0].HostingUSD + out.rows[0].MgmtUSD + out.rows[0].InsuranceUSD + out.rows[0].RepairsUSD)
        : 0;

      // Breakeven BTC price (simplified: total cost / total BTC)
      const totalBtc = out.endingBTC;
      const totalCost = out.capex + out.rows.reduce((a, r) => a + r.PowerUSD + r.HostingUSD + r.MgmtUSD + r.InsuranceUSD + r.RepairsUSD, 0);
      const breakevenPrice = totalBtc > 0 ? totalCost / totalBtc : 0;

      const tr = document.createElement("tr");

      // Highlight current power cost
      const isCurrent = Math.abs(power - basePower) < 0.005;
      const rowStyle = isCurrent ? 'style="background:rgba(96,165,250,.1)"' : '';

      // MOIC color
      let moicStyle = '';
      if (moic >= 1.5) moicStyle = 'color:#34d399';
      else if (moic < 1.0) moicStyle = 'color:#d66a6a';

      tr.innerHTML = `
        <td ${rowStyle}><strong>${sym}${power.toFixed(2)}</strong>${isCurrent ? ' <span class="muted">(current)</span>' : ''}</td>
        <td ${rowStyle} style="${moicStyle}"><strong>${fmtNum(moic, 2)}x</strong></td>
        <td ${rowStyle}>${sym}${Math.round(toDisplay(monthlyOpex)).toLocaleString()}</td>
        <td ${rowStyle}>${sym}${Math.round(toDisplay(breakevenPrice)).toLocaleString()}</td>
      `;
      UI.powerSensitivityTbody.appendChild(tr);
    }
  }
}

// Monte Carlo (batched for smooth UI)
function randn(){
  // Box-Muller transform for normal distribution
  let u=0,v=0;
  while(u===0) u=Math.random();
  while(v===0) v=Math.random();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}

let mcAbortController = null;

async function runMonteCarlo(totalRuns=1000){
  // Abort any previous run
  if (mcAbortController) mcAbortController.abort();
  mcAbortController = new AbortController();
  const signal = mcAbortController.signal;

  const baseScenario = SCENARIOS[state.scenario] ?? SCENARIOS.base;
  const saved = _structuredClone(state);
  const basePrice = getBtcPriceUSD();

  // Show progress bar
  const progressContainer = document.getElementById('mcProgress');
  const progressBar = document.getElementById('mcProgressBar');
  if (progressContainer) progressContainer.style.display = 'block';
  if (progressBar) progressBar.style.width = '0%';

  // Disable rerun button during execution
  setLoading(UI.rerunMC, true);
  UI.rerunMC.textContent = 'Running...';

  let countMoic = 0;
  let countBE = 0;
  let sumEndingBTC = 0;
  let completed = 0;

  const BATCH_SIZE = 50; // Process 50 runs per frame for smooth UI

  try {
    while (completed < totalRuns) {
      if (signal.aborted) break;

      const batchEnd = Math.min(completed + BATCH_SIZE, totalRuns);

      // Run batch synchronously
      for (let i = completed; i < batchEnd; i++) {
        const drift = baseScenario.drift + randn() * 10;
        const amp = baseScenario.amp + randn() * 15;
        const diff = saved.difficultyGrowth + randn() * 10;

        state.priceDrift = clamp(drift, -30, 80);
        state.priceCycleAmp = clamp(amp, 0, 120);
        state.difficultyGrowth = clamp(diff, -20, 80);
        state.btcOverride = String(basePrice);

        const out = model();

        const m18 = Math.min(18, out.rows.length);
        const netValue18 = m18 > 0 ? out.rows[m18-1].NetValueUSD : -out.capex;
        const breakeven = netValue18 >= 0;

        if (out.moic > 1.5) countMoic++;
        if (breakeven) countBE++;
        sumEndingBTC += out.endingBTC;
      }

      completed = batchEnd;

      // Update progress
      const pct = (completed / totalRuns) * 100;
      if (progressBar) progressBar.style.width = `${pct}%`;

      // Update intermediate results
      if (completed % 200 === 0 || completed === totalRuns) {
        UI.probMoic.textContent = fmtNum(100 * countMoic / completed, 1);
        UI.probBreakeven.textContent = fmtNum(100 * countBE / completed, 1);
        UI.avgEndingBtc.textContent = fmtNum(sumEndingBTC / completed, 4);
      }

      // Yield to browser for smooth UI
      await new Promise(resolve => requestAnimationFrame(resolve));
    }
  } finally {
    // Restore state
    state = saved;
    UI.btcOverride.value = saved.btcOverride;

    // Final update
    UI.probMoic.textContent = fmtNum(100 * countMoic / completed, 1);
    UI.probBreakeven.textContent = fmtNum(100 * countBE / completed, 1);
    UI.avgEndingBtc.textContent = fmtNum(sumEndingBTC / completed, 4);

    // Hide progress and re-enable button
    if (progressBar) progressBar.style.width = '100%';
    setTimeout(() => {
      if (progressContainer) progressContainer.style.display = 'none';
      setLoading(UI.rerunMC, false);
      UI.rerunMC.textContent = 'Re-run Monte Carlo';
    }, 300);
  }
}

// ---------- Wiring ----------
function setScenario(val){
  state.scenario = val;
  const s = SCENARIOS[val] || SCENARIOS.base;
  if(s){
    state.priceDrift = Number(s.drift);
    state.priceCycleAmp = Number(s.amp);
    if(UI.priceDrift) UI.priceDrift.value = state.priceDrift;
    if(UI.priceCycleAmp) UI.priceCycleAmp.value = state.priceCycleAmp;
    const driftRange = document.getElementById("priceDriftRange");
    const ampRange = document.getElementById("priceCycleAmpRange");
    if(driftRange) driftRange.value = state.priceDrift;
    if(ampRange) ampRange.value = state.priceCycleAmp;
  }
  document.querySelectorAll(".scenario-btn").forEach(b=>{
    b.classList.toggle("active", b.dataset.val === val);
  });
  recalc();
}

function bindSliders(){
  document.querySelectorAll('input[type="range"][data-bind]').forEach(range=>{
    const key = range.dataset.bind;
    const num = document.getElementById(key);
    if(!num) return;

    // Initialize range to number
    range.value = num.value;

    range.addEventListener("input", ()=>{
      num.value = range.value;
      recalc();
    });
    num.addEventListener("input", ()=>{
      range.value = num.value;
      recalc();
    });
  });
}

function setMinerModelDefaults(){
  const opt = UI.minerModel.options[UI.minerModel.selectedIndex];
  const h = Number(opt.dataset.hash);
  const p = Number(opt.dataset.power);
  const c = Number(opt.dataset.capex);

  // set both number + range controls
  UI.hashratePerMiner.value = h;
  document.getElementById("hashrateRange").value = h;

  UI.powerPerMiner.value = p;
  document.getElementById("powerPerMinerRange").value = p;

  UI.unitCapex.value = c;
  document.getElementById("unitCapexRange").value = c;
}

// --- Enhanced Executive View Update Function ---
function updateExecutiveView(modelOut, sym, dcaBTC, dcaValue) {
  const months = state.holdMonths;
  const endPrice = modelOut.prices[months - 1];

  // Timestamp
  const execTimestamp = document.getElementById("execTimestamp");
  if (execTimestamp) {
    execTimestamp.textContent = new Date().toLocaleDateString('en-US', {
      month: 'short', day: 'numeric', year: 'numeric', hour: '2-digit', minute: '2-digit'
    });
  }

  // Currency symbols
  const symEls = ['execSym1', 'execSym2'];
  symEls.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.textContent = sym;
  });

  // --- Hero Metrics ---
  const moicVal = modelOut.moicNoResale;
  const irrVal = modelOut.irrANoResale;
  const paybackIdx = modelOut.rows.findIndex(r => Number.isFinite(r.NetValueUSD) && r.NetValueUSD >= 0);
  const paybackMonths = paybackIdx === -1 ? null : paybackIdx + 1;

  // MOIC
  const execMoic = document.getElementById("execMoic");
  const heroMoic = document.getElementById("heroMoic");
  if (execMoic) execMoic.textContent = fmtNum(moicVal, 2);
  if (heroMoic) {
    heroMoic.classList.remove('positive', 'negative');
    if (moicVal >= 1.5) heroMoic.classList.add('positive');
    else if (moicVal < 1.0) heroMoic.classList.add('negative');
  }

  // IRR
  const execIrr = document.getElementById("execIrr");
  const heroIrr = document.getElementById("heroIrr");
  if (execIrr) execIrr.textContent = irrVal === null ? "‚Äî" : fmtNum(irrVal * 100, 1);
  if (heroIrr) {
    heroIrr.classList.remove('positive', 'negative');
    if (irrVal !== null) {
      if (irrVal >= 0.20) heroIrr.classList.add('positive');
      else if (irrVal < 0) heroIrr.classList.add('negative');
    }
  }

  // Payback
  const execPayback = document.getElementById("execPayback");
  const heroPayback = document.getElementById("heroPayback");
  const paybackSubtext = document.getElementById("paybackSubtext");
  if (execPayback) execPayback.textContent = paybackMonths === null ? "‚Äî" : String(paybackMonths);
  if (paybackSubtext) {
    if (paybackMonths === null) {
      paybackSubtext.textContent = "not achieved";
    } else if (paybackMonths <= 24) {
      paybackSubtext.textContent = `months (${(paybackMonths / 12).toFixed(1)} yrs)`;
    } else {
      paybackSubtext.textContent = `months (${(paybackMonths / 12).toFixed(1)} yrs)`;
    }
  }
  if (heroPayback) {
    heroPayback.classList.remove('positive', 'negative');
    if (paybackMonths !== null && paybackMonths <= 24) heroPayback.classList.add('positive');
    else if (paybackMonths === null) heroPayback.classList.add('negative');
  }

  // --- Investment Scorecard ---
  const costPerBtc = modelOut.endingBTC > 0 ? (modelOut.capex + modelOut.totalOpex) / modelOut.endingBTC : 0;
  const miningAdvantage = modelOut.endingBTC - dcaBTC;
  const miningAdvPct = dcaBTC > 0 ? ((modelOut.endingBTC / dcaBTC) - 1) * 100 : 0;

  // Score calculations
  let scoreCount = 0;
  let passCount = 0;

  // MOIC score
  const scoreMoicIcon = document.getElementById("scoreMoicIcon");
  const scoreMoicText = document.getElementById("scoreMoicText");
  if (scoreMoicIcon && scoreMoicText) {
    scoreCount++;
    if (moicVal >= 1.5) {
      scoreMoicIcon.className = 'scorecard-icon pass';
      scoreMoicIcon.textContent = '‚úì';
      scoreMoicText.textContent = `${fmtNum(moicVal, 2)}x ‚Äî Strong`;
      passCount++;
    } else if (moicVal >= 1.0) {
      scoreMoicIcon.className = 'scorecard-icon warn';
      scoreMoicIcon.textContent = '‚óè';
      scoreMoicText.textContent = `${fmtNum(moicVal, 2)}x ‚Äî Moderate`;
      passCount += 0.5;
    } else {
      scoreMoicIcon.className = 'scorecard-icon fail';
      scoreMoicIcon.textContent = '‚úó';
      scoreMoicText.textContent = `${fmtNum(moicVal, 2)}x ‚Äî Below target`;
    }
  }

  // Payback score
  const scorePaybackIcon = document.getElementById("scorePaybackIcon");
  const scorePaybackText = document.getElementById("scorePaybackText");
  if (scorePaybackIcon && scorePaybackText) {
    scoreCount++;
    if (paybackMonths !== null && paybackMonths <= 24) {
      scorePaybackIcon.className = 'scorecard-icon pass';
      scorePaybackIcon.textContent = '‚úì';
      scorePaybackText.textContent = `${paybackMonths} mo ‚Äî Within 2 years`;
      passCount++;
    } else if (paybackMonths !== null && paybackMonths <= 36) {
      scorePaybackIcon.className = 'scorecard-icon warn';
      scorePaybackIcon.textContent = '‚óè';
      scorePaybackText.textContent = `${paybackMonths} mo ‚Äî Extended`;
      passCount += 0.5;
    } else {
      scorePaybackIcon.className = 'scorecard-icon fail';
      scorePaybackIcon.textContent = '‚úó';
      scorePaybackText.textContent = paybackMonths ? `${paybackMonths} mo ‚Äî Long` : 'Not achieved';
    }
  }

  // Cost per BTC score
  const scoreCostIcon = document.getElementById("scoreCostIcon");
  const scoreCostText = document.getElementById("scoreCostText");
  const currentPrice = getBtcPriceUSD();
  if (scoreCostIcon && scoreCostText) {
    scoreCount++;
    const costRatio = costPerBtc / currentPrice;
    if (costRatio < 0.5) {
      scoreCostIcon.className = 'scorecard-icon pass';
      scoreCostIcon.textContent = '‚úì';
      scoreCostText.textContent = `${sym}${fmtMoney(toDisplay(costPerBtc), state.currency)} ‚Äî Excellent`;
      passCount++;
    } else if (costRatio < 0.75) {
      scoreCostIcon.className = 'scorecard-icon warn';
      scoreCostIcon.textContent = '‚óè';
      scoreCostText.textContent = `${sym}${fmtMoney(toDisplay(costPerBtc), state.currency)} ‚Äî Moderate`;
      passCount += 0.5;
    } else {
      scoreCostIcon.className = 'scorecard-icon fail';
      scoreCostIcon.textContent = '‚úó';
      scoreCostText.textContent = `${sym}${fmtMoney(toDisplay(costPerBtc), state.currency)} ‚Äî High`;
    }
  }

  // Mining advantage score
  const scoreEdgeIcon = document.getElementById("scoreEdgeIcon");
  const scoreEdgeText = document.getElementById("scoreEdgeText");
  if (scoreEdgeIcon && scoreEdgeText) {
    scoreCount++;
    if (miningAdvPct > 20) {
      scoreEdgeIcon.className = 'scorecard-icon pass';
      scoreEdgeIcon.textContent = '‚úì';
      scoreEdgeText.textContent = `+${fmtNum(miningAdvPct, 0)}% vs buying`;
      passCount++;
    } else if (miningAdvPct > 0) {
      scoreEdgeIcon.className = 'scorecard-icon warn';
      scoreEdgeIcon.textContent = '‚óè';
      scoreEdgeText.textContent = `+${fmtNum(miningAdvPct, 1)}% vs buying`;
      passCount += 0.5;
    } else {
      scoreEdgeIcon.className = 'scorecard-icon fail';
      scoreEdgeIcon.textContent = '‚úó';
      scoreEdgeText.textContent = `${fmtNum(miningAdvPct, 1)}% vs buying`;
    }
  }

  // Overall grade
  const overallGrade = document.getElementById("overallGrade");
  const gradeIcon = document.getElementById("gradeIcon");
  const gradeText = document.getElementById("gradeText");
  if (overallGrade && gradeIcon && gradeText) {
    const scorePct = scoreCount > 0 ? passCount / scoreCount : 0;
    overallGrade.className = 'scorecard-grade';
    if (scorePct >= 0.85) {
      overallGrade.classList.add('excellent');
      gradeIcon.textContent = '‚òÖ';
      gradeText.textContent = 'Excellent';
    } else if (scorePct >= 0.6) {
      overallGrade.classList.add('good');
      gradeIcon.textContent = '‚óè';
      gradeText.textContent = 'Good';
    } else if (scorePct >= 0.35) {
      overallGrade.classList.add('fair');
      gradeIcon.textContent = '‚óê';
      gradeText.textContent = 'Fair';
    } else {
      overallGrade.classList.add('poor');
      gradeIcon.textContent = '‚óã';
      gradeText.textContent = 'Review Needed';
    }
  }

  // --- Mining vs Buying Comparison ---
  const miningBtcEl = document.getElementById("execMiningBtc");
  const miningValueEl = document.getElementById("execMiningValue");
  const dcaBtcEl = document.getElementById("execDcaBtc");
  const dcaValueEl = document.getElementById("execDcaValue");
  const miningCard = document.getElementById("miningCard");
  const buyingCard = document.getElementById("buyingCard");

  if (miningBtcEl) miningBtcEl.textContent = fmtNum(modelOut.endingBTC, 4);
  if (miningValueEl) miningValueEl.textContent = fmtMoney(toDisplay(modelOut.endingBTC * endPrice), state.currency);
  if (dcaBtcEl) dcaBtcEl.textContent = fmtNum(dcaBTC, 4);
  if (dcaValueEl) dcaValueEl.textContent = fmtMoney(toDisplay(dcaValue), state.currency);

  if (miningCard && buyingCard) {
    miningCard.classList.remove('winner');
    buyingCard.classList.remove('winner');
    if (modelOut.endingBTC > dcaBTC) {
      miningCard.classList.add('winner');
    } else if (dcaBTC > modelOut.endingBTC) {
      buyingCard.classList.add('winner');
    }
  }

  // --- Advantage Callout ---
  const execAdvantage = document.getElementById("execAdvantage");
  const execAdvValue = document.getElementById("execAdvValue");
  const execAdvDetail = document.getElementById("execAdvDetail");

  if (execAdvantage && execAdvValue && execAdvDetail) {
    const advBtc = modelOut.endingBTC - dcaBTC;
    const advValue = (modelOut.endingBTC * endPrice) - dcaValue;

    execAdvantage.classList.remove('negative');
    if (advBtc >= 0) {
      execAdvValue.textContent = `+${fmtNum(advBtc, 4)} BTC`;
      execAdvValue.className = 'adv-value positive';
      execAdvDetail.textContent = `${sym}${fmtMoney(toDisplay(advValue), state.currency)} more value via mining`;
    } else {
      execAdvantage.classList.add('negative');
      execAdvValue.textContent = `${fmtNum(advBtc, 4)} BTC`;
      execAdvValue.className = 'adv-value negative';
      execAdvDetail.textContent = `${sym}${fmtMoney(toDisplay(Math.abs(advValue)), state.currency)} less value vs buying`;
    }
  }

  // --- 5-Year Timeline ---
  const execTimeline = document.getElementById("execTimeline");
  if (execTimeline) {
    const yearlyData = [];
    for (let yr = 1; yr <= 5; yr++) {
      const endMonth = Math.min(yr * 12, modelOut.rows.length);
      const btcAccum = modelOut.rows.slice(0, endMonth).reduce((a, r) => a + (Number(r.NetBTC) || 0), 0);
      const price = endMonth <= modelOut.prices.length ? modelOut.prices[endMonth - 1] : endPrice;
      yearlyData.push({ yr, btc: btcAccum, value: btcAccum * price });
    }

    execTimeline.innerHTML = yearlyData.map((d, i) => {
      const isCurrent = (d.yr * 12) === months || (d.yr === 5 && months >= 60);
      return `
        <div class="timeline-year${isCurrent ? ' current' : ''}">
          <div class="yr">Y${d.yr}</div>
          <div class="btc">${fmtNum(d.btc, 3)}</div>
          <div class="val">${sym}${fmtMoney(toDisplay(d.value), state.currency)}</div>
        </div>
      `;
    }).join('');
  }

  // --- Key Assumptions ---
  const execAssumpSummary = document.getElementById("execAssumpSummary");
  if (execAssumpSummary) {
    const basePriceDisp = Math.round(toDisplay(getBtcPriceUSD())).toLocaleString();
    const minerText = UI.minerModel.options[UI.minerModel.selectedIndex].text.split(' ').slice(0, 3).join(' ');

    let priceModelShort = '';
    if (state.priceModel === 'custom') {
      const preset = state.pricePreset !== 'custom' ? state.pricePreset.charAt(0).toUpperCase() + state.pricePreset.slice(1) : 'Custom';
      priceModelShort = `Custom (${preset})`;
    } else {
      priceModelShort = `Cycle ${state.priceDrift > 0 ? '+' : ''}${state.priceDrift.toFixed(0)}%/yr`;
    }

    execAssumpSummary.innerHTML = `
      <div class="assumption-item"><span class="label">Miners:</span> <span class="value">${state.minerCount.toLocaleString()} √ó ${minerText}</span></div>
      <div class="assumption-item"><span class="label">Capex:</span> <span class="value">${sym}${fmtMoney(toDisplay(modelOut.capex), state.currency)}</span></div>
      <div class="assumption-item"><span class="label">Power:</span> <span class="value">${state.powerCost.toFixed(3)} $/kWh</span></div>
      <div class="assumption-item"><span class="label">Start Price:</span> <span class="value">${sym}${basePriceDisp}</span></div>
      <div class="assumption-item"><span class="label">Hold Period:</span> <span class="value">${months} months</span></div>
      <div class="assumption-item"><span class="label">Price Model:</span> <span class="value">${priceModelShort}</span></div>
    `;
  }
}

const recalc = debounce(()=>{
  const startTime = performance.now();
  getInputs();

  // Validate key inputs
  ['minerCount', 'holdMonths', 'uptime', 'powerCost', 'difficultyGrowth', 'networkHashrateEH'].forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      const validation = validateInput(id, el.value);
      applyValidation(el, validation);
    }
  });

  // Keep linked holdMonths range in sync
  UI.holdMonthsRange.value = UI.holdMonths.value;

  // Use cached model when possible
  invalidateModelCache(); // Input changed, so invalidate
  const out = getCachedModel();

  // Use requestAnimationFrame for smooth rendering
  requestAnimationFrame(() => {
    render(out);
    lastRenderTime = Math.round(performance.now() - startTime);
    updatePerfIndicator();
  });
}, 40);

function setTab(tab){
  document.querySelectorAll(".tab-btn").forEach(b=>b.classList.toggle("active", b.dataset.tab===tab));
  document.querySelectorAll(".tab-content").forEach(s=>s.classList.toggle("active", s.id===tab));
}

async function fetchBtcSpot(){
  // Coinbase: GET https://api.coinbase.com/v2/prices/:currency_pair/spot
  // We'll request BTC-USD and store amount. (No auth required per docs.)
  setLoading(UI.refreshPrice, true);
  UI.currentBtcPrice.value = "Fetching...";
  UI.currentBtcPrice.classList.add('loading');

  try{
    const res = await fetch("https://api.coinbase.com/v2/prices/BTC-USD/spot", {cache:"no-store"});
    if(!res.ok) throw new Error("HTTP "+res.status);
    const json = await res.json();
    const amt = Number(json?.data?.amount);
    if(!Number.isFinite(amt)) throw new Error("Bad payload");
    btcSpotUSD = amt;
    const disp = state.currency === "EUR" ? (amt * fxRate()) : amt;
    const sym = symbolFor(state.currency);
    UI.currentBtcPrice.value = sym + Math.round(disp).toLocaleString();
    UI.currentBtcPrice.classList.remove('warning', 'error');
    UI.assumptionsBtcPrice.textContent = sym + Math.round(disp).toLocaleString();
  }catch(err){
    // Graceful fallback with helpful message
    UI.currentBtcPrice.value = "Enter price manually ‚Üí";
    UI.currentBtcPrice.classList.add('warning');
    btcSpotUSD = null;
  }finally{
    UI.currentBtcPrice.classList.remove('loading');
    setLoading(UI.refreshPrice, false);
    invalidateModelCache();

    // Update price projection display with new BTC price
    if (typeof updatePriceProjectionDisplay === 'function') {
      updatePriceProjectionDisplay();
    }

    recalc();
  }
}

async function fetchHashrateSpot(){
  // Try multiple APIs for network hashrate
  setLoading(UI.refreshHashrate, true);
  if(UI.hashrateStatus) {
    UI.hashrateStatus.textContent = "Fetching hashrate...";
    UI.hashrateStatus.classList.remove('validation-msg', 'warning', 'error', 'success');
  }

  let eh = null;

  // Try mempool.space API first (more reliable CORS)
  try {
    const res = await fetch("https://mempool.space/api/v1/mining/hashrate/1w", {cache:"no-store"});
    if(res.ok) {
      const json = await res.json();
      // Returns hashrates array with avgHashrate in H/s
      const current = json?.currentHashrate || json?.hashrates?.[json.hashrates.length-1]?.avgHashrate;
      if(Number.isFinite(current) && current > 0) {
        eh = current / 1e18; // H/s to EH/s
      }
    }
  } catch {}

  // Fallback: Blockchain.info API
  if (!eh) {
    try {
      const res = await fetch("https://api.blockchain.info/charts/hash-rate?timespan=30days&format=json&sampled=true", {cache:"no-store"});
      if(res.ok) {
        const json = await res.json();
        const values = Array.isArray(json?.values) ? json.values : [];
        const last = values.length ? values[values.length - 1] : null;
        const th = Number(last?.y);
        if(Number.isFinite(th) && th > 0) {
          eh = th / 1_000_000; // TH/s to EH/s
        }
      }
    } catch {}
  }

  if (eh && Number.isFinite(eh) && eh > 0) {
    UI.networkHashrateEH.value = Math.round(eh).toString();
    document.getElementById("networkHashRange").value = UI.networkHashrateEH.value;
    if(UI.hashrateStatus) {
      UI.hashrateStatus.textContent = `‚úì ${Math.round(eh).toLocaleString()} EH/s (${new Date().toLocaleTimeString()})`;
      UI.hashrateStatus.classList.add('validation-msg', 'success');
    }
    invalidateModelCache();
    recalc();
  } else {
    if(UI.hashrateStatus) {
      UI.hashrateStatus.textContent = "Fetch failed ‚Äî enter manually or retry";
      UI.hashrateStatus.classList.add('validation-msg', 'warning');
    }
  }

  setLoading(UI.refreshHashrate, false);
}



async function fetchFxSpot(){
  // Primary: open.er-api.com (no key). Fallback: ECB daily reference.
  setLoading(UI.refreshFx, true);
  const originalValue = UI.fxRate.value;
  let success = false;

  try {
    // Try primary API first
    const res = await fetch("https://open.er-api.com/v6/latest/USD", {cache:"no-store"});
    if(res.ok){
      const json = await res.json();
      const rate = Number(json?.rates?.EUR);
      if(Number.isFinite(rate) && rate > 0){
        UI.fxRate.value = rate.toFixed(4);
        UI.fxRate.classList.remove('warning');
        success = true;
      }
    }
  } catch {}

  // ECB fallback if primary failed
  if (!success) {
    try {
      const res = await fetch("https://www.ecb.europa.eu/stats/eurofxref/eurofxref-daily.xml", {cache:"no-store"});
      if(res.ok) {
        const txt = await res.text();
        const mm = txt.match(/currency=['\"]USD['\"]\s+rate=['\"]([0-9.]+)['\"]/);
        if(mm){
          const eurToUsd = Number(mm[1]);
          if(Number.isFinite(eurToUsd) && eurToUsd > 0){
            UI.fxRate.value = (1/eurToUsd).toFixed(4);
            UI.fxRate.classList.remove('warning');
            success = true;
          }
        }
      }
    } catch {}
  }

  // If both failed, keep original and show warning
  if (!success) {
    UI.fxRate.value = originalValue;
    UI.fxRate.classList.add('warning');
  }

  // Always clear loading state
  setLoading(UI.refreshFx, false);
  invalidateModelCache();
  recalc();
}

/**
 * Applies the current state to all UI elements.
 * Uses syncInputRange helper for slider/input pairs to reduce duplication.
 */
function applyStateToUI(){
  // Simple selects and inputs
  UI.minerModel.value = state.minerModel;
  UI.currency.value = state.currency;
  UI.fxRate.value = state.fxRate;
  UI.minerCount.value = state.minerCount;
  UI.btcOverride.value = state.btcOverride;
  UI.halvingAnchor.value = state.halvingAnchor;
  UI.reinvestBtc.checked = state.reinvestBtc;

  // Paired slider/input controls - using helper for cleaner code
  syncInputRange("holdMonths", "holdMonthsRange", state.holdMonths);
  syncInputRange("priceDrift", "priceDriftRange", state.priceDrift);
  syncInputRange("priceCycleAmp", "priceCycleAmpRange", state.priceCycleAmp);
  syncInputRange("priceCycleMonths", "priceCycleMonthsRange", state.priceCycleMonths);
  syncInputRange("unitCapex", "unitCapexRange", state.unitCapex);
  syncInputRange("powerCost", "powerCostRange", state.powerCost);
  syncInputRange("hashratePerMiner", "hashrateRange", state.hashratePerMiner);
  syncInputRange("powerPerMiner", "powerPerMinerRange", state.powerPerMiner);
  syncInputRange("networkHashrateEH", "networkHashRange", state.networkHashrateEH);
  syncInputRange("uptime", "uptimeRange", state.uptime);
  syncInputRange("poolFee", "poolFeeRange", state.poolFee);
  syncInputRange("hostingFee", "hostingFeeRange", state.hostingFee);
  syncInputRange("managementFee", "managementFeeRange", state.managementFee);
  syncInputRange("insuranceFee", "insuranceFeeRange", state.insuranceFee);
  syncInputRange("repairReserve", "repairRange", state.repairReserve);
  syncInputRange("degradation", "degradeRange", state.degradation);
  syncInputRange("difficultyGrowth", "diffRange", state.difficultyGrowth);
  syncInputRange("resaleValue", "resaleRange", state.resaleValue);

  // Custom price projection inputs
  if (UI.priceY1) UI.priceY1.value = state.priceY1;
  if (UI.priceY2) UI.priceY2.value = state.priceY2;
  if (UI.priceY3) UI.priceY3.value = state.priceY3;
  if (UI.priceY4) UI.priceY4.value = state.priceY4;
  if (UI.priceY5) UI.priceY5.value = state.priceY5;

  // Apply price model mode
  if (typeof setPriceModel === 'function') {
    setPriceModel(state.priceModel || 'cycle');
  }
  if (typeof applyPricePreset === 'function' && state.pricePreset) {
    // Just update button states, don't overwrite values
    document.querySelectorAll('.price-preset-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.preset === state.pricePreset);
    });
  }

  // Investor mode
  if(UI.investorMode) UI.investorMode.checked = !!state.investorMode;
  applyInvestorMode();

  // Keep cashflow view coherent with mode
  if(!state.cashflowView) state.cashflowView = state.investorMode ? "annual" : "monthly";

  setScenario(state.scenario);
}

function resetAll(){
  state = _structuredClone(DEFAULTS);

  // Reset scenario buttons
  document.querySelectorAll(".scenario-btn").forEach(b=>b.classList.toggle("active", b.dataset.val===DEFAULTS.scenario));

  // Reset price model and presets
  document.querySelectorAll('.price-model-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.mode === DEFAULTS.priceModel);
  });
  document.querySelectorAll('.price-preset-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.preset === 'custom');
  });

  applyStateToUI();
  btcSpotUSD = null;
  UI.currentBtcPrice.value = "";

  // Update price projection display
  if (typeof updatePriceProjectionDisplay === 'function') {
    setTimeout(updatePriceProjectionDisplay, 100);
  }

  recalc();
  runMonteCarlo(1000);
}

// Event listeners
document.querySelectorAll(".scenario-btn").forEach(btn=>{
  btn.addEventListener("click", ()=> setScenario(btn.dataset.val));
});
document.querySelectorAll(".tab-btn").forEach(btn=>{
  btn.addEventListener("click", ()=> setTab(btn.dataset.tab));
});

UI.toggleAssumptions.addEventListener("click", ()=>{
  const open = UI.assumptionsPanel.style.display !== "none";
  UI.assumptionsPanel.style.display = open ? "none" : "block";
  UI.toggleAssumptions.textContent = open ? "Show Assumptions" : "Hide Assumptions";
});

UI.minerMinus.addEventListener("click", ()=>{
  UI.minerCount.value = String(Math.max(1, Number(UI.minerCount.value||1) - 1));
  recalc();
});
UI.minerPlus.addEventListener("click", ()=>{
  UI.minerCount.value = String(Number(UI.minerCount.value||1) + 1);
  recalc();
});

UI.minerModel.addEventListener("change", ()=>{
  setMinerModelDefaults();
  recalc();
});

["currency","fxRate","minerCount","holdMonths","btcOverride","priceDrift","priceCycleAmp","priceCycleMonths","halvingAnchor","reinvestBtc"].forEach(id=>{
  document.getElementById(id).addEventListener("input", recalc);
});

// Update price projection when BTC price or cycle params change
["btcOverride", "priceDrift", "priceCycleAmp"].forEach(id => {
  const el = document.getElementById(id);
  if (el) {
    el.addEventListener("input", () => {
      if (typeof updatePriceProjectionDisplay === 'function') {
        updatePriceProjectionDisplay();
      }
      // Also update the cycle note details
      if (UI.cycleNoteDetails) {
        UI.cycleNoteDetails.textContent = `${state.priceDrift}% drift, ¬±${state.priceCycleAmp}% amplitude`;
      }
    });
  }
});
[
  "unitCapex","powerCost","hashratePerMiner","powerPerMiner","networkHashrateEH","uptime",
  "poolFee","hostingFee","managementFee","insuranceFee","repairReserve","degradation","difficultyGrowth","resaleValue"
].forEach(id => document.getElementById(id).addEventListener("input", recalc));

UI.refreshPrice.addEventListener("click", fetchBtcSpot);
UI.refreshFx.addEventListener("click", fetchFxSpot);
UI.refreshHashrate && UI.refreshHashrate.addEventListener("click", fetchHashrateSpot);

UI.exportBtn.addEventListener("click", ()=>{
  const out = model();
  const exportRows = out.rows.map(r => ({
    Month: r.Month,
    GrossBTC: round(r.GrossBTC, 8),
    PoolFeeBTC: round(r.PoolFeeBTC, 8),
    NetBTC: round(r.NetBTC, 8),
    BTCPriceUSD: round(r.BTCPrice, 2),
    RevenueUSD: round(r.RevenueUSD, 2),
    PowerUSD: round(r.PowerUSD, 2),
    HostingUSD: round(r.HostingUSD, 2),
    MgmtUSD: round(r.MgmtUSD, 2),
    InsuranceUSD: round(r.InsuranceUSD, 2),
    RepairsUSD: round(r.RepairsUSD, 2),
    NetCashUSD: round(r.NetCashUSD, 2),
    CumNetValueUSD: round(r.NetValueUSD, 2),
  }));
  exportCSV(exportRows);
});

UI.shareBtn.addEventListener("click", shareScenario);
UI.exportHtmlBtn && UI.exportHtmlBtn.addEventListener("click", exportOnePager);
UI.exportPdfBtn && UI.exportPdfBtn.addEventListener("click", exportPdfOnePager);
UI.toggleCashflowView && UI.toggleCashflowView.addEventListener("click", ()=>{
  state.cashflowView = (state.cashflowView === "monthly") ? "annual" : "monthly";
  applyStateToUI();
  recalc();
});
UI.investorMode && UI.investorMode.addEventListener("change", ()=>{
  state.investorMode = UI.investorMode.checked;
  applyInvestorMode();
  applyStateToUI();
  recalc();
});

UI.rerunMC.addEventListener("click", ()=>runMonteCarlo(1000));
UI.resetBtn.addEventListener("click", resetAll);

// ========== PRICE PROJECTION PANEL ==========
let priceSparklineChart = null;

/**
 * Updates the year-end price displays and sparkline chart
 */
function updatePriceProjectionDisplay() {
  if (state.priceModel !== "custom") return;

  const prices = getYearEndPrices();
  const sym = symbolFor(state.currency);
  const startPrice = prices[0];

  // Update each year's display
  for (let i = 1; i <= 5; i++) {
    const displayEl = document.getElementById(`priceY${i}Display`);
    if (displayEl) {
      const price = prices[i];
      const displayPrice = toDisplay(price);
      displayEl.textContent = `${sym}${Math.round(displayPrice).toLocaleString()}`;

      // Visual feedback for extreme values
      displayEl.classList.remove('negative', 'extreme');
      if (price < startPrice * 0.3) {
        displayEl.classList.add('negative');
      } else if (price > startPrice * 5) {
        displayEl.classList.add('extreme');
      }
    }
  }

  // Update sparkline
  updatePriceSparkline(prices);
}

/**
 * Creates/updates the sparkline chart showing 5-year price trajectory
 */
function updatePriceSparkline(prices) {
  const canvas = UI.priceSparkline;
  if (!canvas || typeof Chart === 'undefined') return;

  const labels = ['Start', 'Y1', 'Y2', 'Y3', 'Y4', 'Y5'];
  const displayPrices = prices.map(p => toDisplay(p));

  // Determine if trajectory is overall positive or negative
  const isPositive = displayPrices[5] >= displayPrices[0];
  const lineColor = isPositive ? 'rgba(52, 211, 153, 0.9)' : 'rgba(214, 106, 106, 0.9)';
  const fillColor = isPositive ? 'rgba(52, 211, 153, 0.15)' : 'rgba(214, 106, 106, 0.15)';

  if (!priceSparklineChart) {
    priceSparklineChart = new Chart(canvas, {
      type: 'line',
      data: {
        labels,
        datasets: [{
          data: displayPrices,
          borderColor: lineColor,
          backgroundColor: fillColor,
          borderWidth: 2,
          pointRadius: 3,
          pointBackgroundColor: lineColor,
          fill: true,
          tension: 0.3
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              label: (ctx) => `${symbolFor(state.currency)}${Math.round(ctx.raw).toLocaleString()}`
            }
          }
        },
        scales: {
          x: { display: false },
          y: {
            display: false,
            beginAtZero: false
          }
        },
        interaction: { mode: 'index', intersect: false }
      }
    });
  } else {
    priceSparklineChart.data.datasets[0].data = displayPrices;
    priceSparklineChart.data.datasets[0].borderColor = lineColor;
    priceSparklineChart.data.datasets[0].backgroundColor = fillColor;
    priceSparklineChart.data.datasets[0].pointBackgroundColor = lineColor;
    priceSparklineChart.update('none');
  }
}

/**
 * Sets the price model mode (cycle vs custom)
 */
function setPriceModel(mode) {
  state.priceModel = mode;

  // Update UI
  document.querySelectorAll('.price-model-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.mode === mode);
  });

  if (UI.customPriceControls) {
    UI.customPriceControls.style.display = mode === 'custom' ? 'block' : 'none';
  }
  if (UI.cycleModelNote) {
    UI.cycleModelNote.style.display = mode === 'cycle' ? 'block' : 'none';
  }

  // Update cycle note details
  if (UI.cycleNoteDetails) {
    UI.cycleNoteDetails.textContent = `${state.priceDrift}% drift, ¬±${state.priceCycleAmp}% amplitude`;
  }

  if (mode === 'custom') {
    updatePriceProjectionDisplay();
  }

  invalidateModelCache();
  recalc();
}

/**
 * Applies a price preset to all year inputs
 */
function applyPricePreset(presetName) {
  const preset = PRICE_PRESETS[presetName];
  if (!preset) return;

  state.pricePreset = presetName;

  // Update preset buttons
  document.querySelectorAll('.price-preset-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.preset === presetName);
  });

  // Only apply values if not "custom" (custom keeps user's values)
  if (presetName !== 'custom') {
    state.priceY1 = preset.y1;
    state.priceY2 = preset.y2;
    state.priceY3 = preset.y3;
    state.priceY4 = preset.y4;
    state.priceY5 = preset.y5;

    // Update UI inputs
    if (UI.priceY1) UI.priceY1.value = preset.y1;
    if (UI.priceY2) UI.priceY2.value = preset.y2;
    if (UI.priceY3) UI.priceY3.value = preset.y3;
    if (UI.priceY4) UI.priceY4.value = preset.y4;
    if (UI.priceY5) UI.priceY5.value = preset.y5;
  }

  updatePriceProjectionDisplay();
  invalidateModelCache();
  recalc();
}

// Price model selector event listeners
document.querySelectorAll('.price-model-btn').forEach(btn => {
  btn.addEventListener('click', () => setPriceModel(btn.dataset.mode));
});

// Price preset button event listeners
document.querySelectorAll('.price-preset-btn').forEach(btn => {
  btn.addEventListener('click', () => applyPricePreset(btn.dataset.preset));
});

// Year input event listeners
['priceY1', 'priceY2', 'priceY3', 'priceY4', 'priceY5'].forEach(id => {
  const el = document.getElementById(id);
  if (el) {
    el.addEventListener('input', () => {
      // When user edits, switch to "Custom" preset
      state.pricePreset = 'custom';
      document.querySelectorAll('.price-preset-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.preset === 'custom');
      });
      updatePriceProjectionDisplay();
      invalidateModelCache();
      recalc();
    });
  }
});

// Price projection panel collapse/expand
if (UI.priceProjectionHeader) {
  UI.priceProjectionHeader.addEventListener('click', () => {
    UI.priceProjectionPanel.classList.toggle('collapsed');
  });
}

// init
loadFromQuery();
applyStateToUI();
applyInvestorMode();
bindSliders();
setMinerModelDefaults();
fetchFxSpot();
fetchBtcSpot();

// Initialize price projection display after BTC price is fetched
setTimeout(() => {
  if (typeof updatePriceProjectionDisplay === 'function') {
    updatePriceProjectionDisplay();
  }
}, 500);

recalc();
runMonteCarlo(1000);

// ---- Advanced Assumptions collapse ----
(function(){
  const panel = document.getElementById("advancedAssumptions");
  const btn = document.getElementById("toggleAdvanced");
  if(!panel || !btn) return;

  const saved = localStorage.getItem("showAdvancedAssumptions");
  const open = saved === "1";
  panel.style.display = open ? "block" : "none";
  btn.textContent = open ? "Hide" : "Show";

  btn.addEventListener("click", ()=>{
    // In Investor Mode, the first click "unlocks" advanced assumptions
    if(state.investorMode && !state.advancedUnlocked){
      state.advancedUnlocked = true;
      panel.style.display = "block";
      setAdvancedEnabled(true);
      btn.textContent = "Hide";
      localStorage.setItem("showAdvancedAssumptions", "1");
      return;
    }
    const isOpen = panel.style.display !== "none";
    panel.style.display = isOpen ? "none" : "block";
    btn.textContent = isOpen ? "Show" : "Hide";
    localStorage.setItem("showAdvancedAssumptions", isOpen ? "0" : "1");
  });

  // Re-apply Investor Mode lock rules after restoring saved state
  if(typeof applyInvestorMode === "function") applyInvestorMode();
})();

</script>
</body>
</html>
